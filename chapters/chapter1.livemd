## Elixir e Erlang
### Historia de Erlang
BEAM, a máquina virtual de Erlang. Por que a máquina virtual de Erlang se chama BEAM e não EVM?

Por motivos históricos explicados em A history of Erlang, de Joe Armstrong. Simplificando: por volta de 1990 havia a JAM, Joe Abstract Machine, onde "Joe" refere-se a Joe Armstrong, um dos criadores da linguagem. Em 1993 a equipe do Erlang decidiu criar uma versão mais eficiente da máquina virtual de Erlang. Bogumil (Bogdan) Hausman foi o principal criador desta linguagem e o nome inicial dela era Turbo Erlang. Mas como Turbo era uma marca da empresa Borland, renomearam a máquina para BEAM: Bogdan's Erlang Abstract Machine.


O ecossistema de Erlang refere-se ao conjunto de tecnologias, ferramentas, bibliotecas e comunidades relacionadas à linguagem de programação Erlang. Erlang é uma linguagem de programação funcional, concorrente e tolerante a falhas, desenvolvida pela Ericsson no final dos anos 80.

O ecossistema de Erlang é conhecido por sua força em sistemas distribuídos e de tempo real, especialmente em aplicativos de telecomunicações e comunicações em larga escala. Ele oferece recursos poderosos para lidar com concorrência, escalabilidade e resiliência, tornando-o adequado para sistemas altamente disponíveis e que exigem baixa latência.

### Alguns exemplos dentro de Erlang
Dentro do ecossistema de Erlang, existem várias ferramentas e bibliotecas notáveis que complementam a linguagem. Alguns exemplos incluem:

OTP (Open Telecom Platform): É um conjunto de bibliotecas e frameworks que fornecem abstrações e componentes reutilizáveis para o desenvolvimento de sistemas distribuídos robustos. O OTP inclui o "Supervisor", que gerencia a tolerância a falhas, e o "GenServer", que permite criar processos concorrentes.

Cowboy: É um servidor web assíncrono em Erlang, projetado para lidar com alto tráfego e requisitos de baixa latência. Ele fornece um ambiente para criar aplicativos web escaláveis e de alto desempenho.

RabbitMQ: É um sistema de mensagens assíncronas baseado em Erlang. Ele fornece uma plataforma de mensagens robusta e escalável para integração de sistemas distribuídos.

Elixir: Embora tecnicamente não seja parte do ecossistema de Erlang, vale a pena mencionar o Elixir. Ele é uma linguagem de programação funcional construída em cima da máquina virtual Erlang (BEAM). Elixir aproveita os recursos do ecossistema de Erlang, mas oferece uma sintaxe mais moderna e uma abordagem mais amigável para a programação.

Além disso, o ecossistema de Erlang é suportado por uma comunidade ativa de desenvolvedores, com conferências, fóruns online e recursos educacionais disponíveis para compartilhar conhecimento e promover a colaboração.

Em resumo, o ecossistema de Erlang é um conjunto de recursos, ferramentas e comunidades relacionadas à linguagem de programação Erlang, que enfatiza a construção de sistemas distribuídos, tolerantes a falhas e de alto desempenho.

### Historia de Elixir
Elixir, é uma linguagem de berço brasileiro, criada, desenvolvida e mantida por José Valim, em 2011, junto com o núcleo de Desenvolvimento e Pesquisa (R&D) da Plataformatec.

De acordo com sua própria definição, o Elixir é "uma linguagem dinâmica e funcional, desenhada para construir aplicações escaláveis e sustentáveis".

A linguagem foi desenvolvida para ser executada sobre a máquina virtual Erlang VM, com o objetivo de ampliar a produtividade e extensibilidade do ecossistema da linguagem Erlang, criada na década de 80 para múltiplos fins.

### Promessas vitais

Um dos casos de maior sucesso de execução do Elixir, dentro do ecossistema web, é a plataforma de comunicação Discord.

Segundo a equipe de desenvolvedores, a escolha pelo Elixir veio desde o início, quando miravam em criar um sistema altamente concorrente em tempo real — o protótipo do Discord foi programado em Elixir, apostando nas promessas que a linguagem fazia ao rodar na máquina virtual.

Para eles, a "promessa Elixir" era simples: "acessar o poder da Erlang VM por meio de uma linguagem muito mais moderna e amigável ao usuário.

## O que é um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profissão. O salário mensal de Maria é R$ 5.050,55.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Você deve ter percebido que, ao escrever o nome e a profissão, usamos aspas. E, ao escrever o salário, usamos "." (ponto) no lugar da "," (vírgula) e não colocamos a moeda ("R$"). Explicaremos isto depois.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima têm tipos diferentes.

## Quais são os tipos de valores?

### Tipos Básicos

### Inteiros
```elixir
iex> 255
255
```
O suporte para números binários, octais e hexadecimais também estão inclusos:
```elixir
iex> 0b0110
6
iex> 0o644
420
iex> 0x1F
31
```

### Pontos Flutuantes
Em Elixir, os números de ponto flutuante requerem um decimal depois de pelo menos um dígito; estes possuem uma precisão de 64 bits e suportam e para números exponenciais:
```elixir
iex> 3.14
 3.14
iex> .14
** (SyntaxError) iex:2: syntax error before: '.'
iex> 1.0e-10
1.0e-10
```

### Booleanos
Elixir suporta true e false como booleanos; todo valor é verdadeiro com exceção de false e nil:
```elixir
iex> true
true
iex> false
false
```

### Átomos
Um átomo é uma constante cujo o nome é seu valor. Se está familiarizado com Ruby, estes são equivalentes aos símbolos:
```elixir
iex> :foo
:foo
iex> :foo == :bar
false
```
Booleanos true e false também são os átomos :true e :false, respectivamente.
```elixir
iex> is_atom(true)
true
iex> is_boolean(:true)
true
iex> :true === true
true
```
Nomes de módulos em Elixir também são átomos. MyApp.MyModule é um átomo válido, mesmo se tal módulo ainda não tenha sido declarado.
```elixir
iex> is_atom(MyApp.MyModule)
true
```
Átomos também são usados para referenciar módulos de bibliotecas Erlang, incluindo as bibliotecas integradas.
```elixir
iex> :crypto.strong_rand_bytes 3
<<23, 104, 108>>
```
### Strings
As strings em Elixir são codificadas em UTF-8 e são representadas com aspas duplas:
```elixir
iex> "Hello"
"Hello"
iex> "dziękuję"
"dziękuję"
```
As strings suportam quebras de linha e caracteres de escape:
```elixir
iex> "foo
...> bar"
"foo\nbar"
iex> "foo\nbar"
"foo\nbar"
```

## O que é o casamento de padrões?

Pattern matching é uma poderosa parte de Elixir que nos permite procurar padrões simples em valores, estruturas de dados, e até funções. Nesta lição iremos começar a ver como pattern matching é usado.
### Operador Match
Você está preparado para ficar um pouco confuso? Em Elixir, o operador = é na verdade o nosso operador match, comparável ao sinal de igualdade da matemática. Quando usado, a expressão inteira se torna uma equação e faz com que Elixir combine os valores do lado esquerdo com os valores do lado direito da expressão. Se a comparação for bem sucedida, o valor da equação é retornado. Se não, um erro é lançado. Vejamos a seguir:
```elixir
iex> x = 1
1
```
Agora vamos tentar a simples correspondência:
```elixir
iex> 1 = x
1
iex> 2 = x
** (MatchError) no match of right hand side value: 1
```
Vamos tentar isso com algumas das coleções que nós conhecemos:
```elixir
# Listas
iex> list = [1, 2, 3]
[1, 2, 3]
[1, 2, 3] = list
[1, 2, 3]
[] = list
** (MatchError) no match of right hand side value: [1, 2, 3]

iex> [1 | tail] = list
[1, 2, 3]
iex> tail
[2, 3]
iex> [2 | _] = list
** (MatchError) no match of right hand side value: [1, 2, 3]

# Tuplas
iex> {:ok, value} = {:ok, "Successful!"}
{:ok, "Successful!"}
iex> value
"Successful!"
iex> {:ok, value} = {:error}
** (MatchError) no match of right hand side value: {:error}
```
### Operador Pin
Acabamos de aprender que o operador match manuseia atribuições quando o lado esquerdo da associação é uma variável. Em alguns casos este comportamento de reassociação de variável é algo não desejável. Para estas situações, nós temos o operador pin:^.
Quando fixamos a variável em associação ao valor existente ao invés de reassociar a um novo valor. Vamos ver como isso funciona:
```elixir
iex> x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2
iex> {x, ^x} = {2, 1}
{2, 1}
iex> x
2
```

Elixir 1.2 introduziu suporte para pins em chaves de mapas e cláusulas de função:
```elixir
iex> key = "hello"
"hello"
iex> %{^key => value} = %{"hello" => "world"}
%{"hello" => "world"}
iex> value
"world"
iex> %{^key => value} = %{:hello => "world"}
** (MatchError) no match of right hand side value: %{hello: "world"}
```
Um exemplo do uso do pin em uma cláusula de função:
```elixir
iex> greeting = "Hello"
"Hello"
iex> greet = fn
...>  (^greeting, name) -> "Hi #{name}"
...>  (greeting, name) -> "#{greeting}, #{name}"
...> end
#Function<12.54118792/2 in :erl_eval.expr/5>
iex> greet.("Hello", "Sean")
"Hi Sean"
iex> greet.("Mornin'", "Sean")
"Mornin', Sean"
iex> greeting
"Hello"
```
Note que no exemplo "Mornin'", a reassociação de greeting para "Mornin'" só acontece dentro de uma função. Fora da função, greeting continua sendo "Hello".

## O que é uma variável?

Em Elixir, uma variável é um nome que você associa a um valor ou a uma expressão. As variáveis são usadas para armazenar dados que podem ser usados posteriormente em um programa. Aqui estão algumas características importantes das variáveis em Elixir:

Padrão de Imutabilidade: Em Elixir, as variáveis são imutáveis, o que significa que uma vez que você atribui um valor a uma variável, não pode alterá-lo. Em vez disso, quando você "altera" o valor de uma variável, na verdade está criando uma nova variável com um novo valor. Isso é fundamental para o paradigma funcional de Elixir.

Ámbito de Variável: As variáveis têm um escopo local. Isso significa que uma variável definida em uma função ou em um bloco de código só é acessível dentro desse escopo. Isso ajuda a evitar conflitos de nomes de variáveis em partes diferentes de um programa.

Convenções de Nomenclatura: Em Elixir, as variáveis são geralmente escritas em letras minúsculas e podem conter letras, números e sublinhados. Por exemplo, nome, idade, minha_variavel, etc.

Aqui está um exemplo simples de como criar e usar variáveis em Elixir:
```elixir
# Definindo uma variável
iex> nome = "João"

# Usando a variável
iex> IO.puts("Olá, #{nome}!")

# Tentativa de reatribuir a variável (isso não funcionará)
nome = "Maria"  # Isso cria uma nova variável chamada "nome" com o novo valor, não modifica a variável original
```
No exemplo acima, criamos uma variável chamada nome e a utilizamos em uma saída de texto. Quando tentamos atribuir um novo valor a nome, na verdade estamos criando uma nova variável nome com o valor "Maria", mas a variável original nome permanece inalterada.

Em resumo, as variáveis em Elixir são usadas para armazenar valores imutáveis ​​e são uma parte fundamental da programação funcional em Elixir.

## Como atribuir um valor a uma variável?

Em Elixir, você pode atribuir um valor a uma variável usando o operador "=". Aqui está um exemplo simples de como fazer isso:

```elixir
# Definindo uma variável chamada "nome" com o valor "João"
iex> nome = "João"

# Usando a variável
iex> IO.puts("Olá, #{nome}!")
```
Neste exemplo, estamos definindo uma variável chamada nome e atribuindo a ela o valor "João". Em seguida, usamos a variável nome em uma saída de texto. A variável nome agora contém o valor "João" e pode ser usada em qualquer lugar dentro do escopo em que foi definida.

Lembre-se de que, em Elixir, as variáveis são imutáveis, o que significa que, uma vez que você atribui um valor a uma variável, não pode alterá-lo. Se você tentar atribuir um novo valor à mesma variável, na verdade estará criando uma nova variável com o novo valor, como mencionado anteriormente.

## O que é Coleção?

Em Elixir, uma coleção refere-se a uma estrutura de dados que pode armazenar um conjunto de valores. As coleções mais comuns em Elixir incluem listas, tuplas, mapas e conjuntos. Cada uma dessas coleções tem suas próprias características e é adequada para diferentes tipos de operações. Aqui estão algumas informações sobre cada uma delas:

### Listas
Uma lista é uma coleção ordenada de elementos em que cada elemento é separado por uma vírgula e cercado por colchetes [ ]. As listas em Elixir são imutáveis, o que significa que você não pode alterar uma lista existente, mas pode criar uma nova lista com elementos adicionados ou removidos.

Exemplo de lista em Elixir:

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```
Elixir implementa listas como listas encadeadas. Isso significa que acessar o tamanho da lista é uma operação que rodará em tempo linear (O(n)). Por essa razão, é normalmente mais rápido inserir um elemento no início (prepending) do que no final (appending):

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Prepending (rápido)
iex> ["π" | list]
["π", 3.14, :pie, "Apple"]
# Appending (lento)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### Concatenação de listas
A concatenação de listas usa o operador ++/2.

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

Uma pequena nota sobre o formato de nome (++/2) usado acima. Em Elixir (e Erlang, sobre o qual Elixir é construído), o nome de uma função ou operador tem dois componentes: o nome em si (neste caso ++) e sua aridade. Aridade é uma parte central quando se fala sobre código Elixir (e Erlang). Indica o número de argumentos que uma dada função aceita (dois, nesse nosso exemplo). Aridade e o nome são combinados com uma barra. Falaremos mais sobre isto mais tarde; este conhecimento irá ajudá-lo a entender a notação por enquanto.

### Subtração de listas
O suporte para subtração é provido pelo operador --/2; é seguro subtrair um valor que não existe:
```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

Esteja atento para valores duplicados. Para cada elemento na direita, a primeira ocorrência deste é removida da esquerda:

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```
Nota: subtração de listas usa comparação estrita para match de valores. Por exemplo:

```elixir
iex> [2] -- [2.0]
[2]
iex> [2.0] -- [2.0]
[]
```

### Topo / Cauda
Quando usamos listas é comum trabalhar com o topo e o fim da lista. O topo é o primeiro elemento da lista e a cauda são os elementos restantes. Elixir provê duas funções bem úteis, hd e tl, para trabalhar com essas partes:

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```

Além das funções citadas, pode-se usar pattern matching e o operador cons (|) para dividir a lista em topo e cauda; veremos este padrão em futuras lições:

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

### Tuplas
Uma tupla é uma coleção ordenada de elementos, semelhante a uma lista, mas é imutável e geralmente contém um número fixo de elementos. As tuplas são definidas usando chaves { }.

Exemplo de tupla em Elixir:
```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```
É comum usar tuplas como um mecanismo que retorna informação adicional de funções; a utilidade disso ficará mais aparente quando vermos pattern matching:

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

### Listas de palavras-chave
As listas de palavras-chave e os mapas são coleções associativas no Elixir. No Elixir, uma lista de palavras-chave é uma lista especial de tuplas de dois elementos cujo o primeiro elemento é um átomo; eles compartilham o desempenho das listas:

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

As três características relevantes das listas de palavras-chave são:

As chaves são átomos.
As chaves estão ordenadas.
As chaves não são únicas.
Por essas razões as listas de palavras-chave são frequentemente usadas para passar opções a funções.

### Mapas

Em Elixir, mapas normalmente são a escolha para armazenamento chave-valor. A diferença entre os mapas e as listas de palavras-chave está no fato de que os mapas permitem chaves de qualquer tipo e não seguem uma ordem. Você pode definir um mapa com a sintaxe %{}:

map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
map[:foo]
"bar"
map["hello"]
:world
A partir do Elixir 1.2, variáveis são permitidas como chaves do mapa:

key = "hello"
"hello"
%{key => "world"}
%{"hello" => "world"}
Se um elemento duplicado é inserido no mapa, este sobrescreverá o valor anterior;

%{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
Como podemos ver na saída anterior, há uma sintaxe especial para os mapas que contém apenas átomos como chaves:

%{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
Além disso, existe uma sintaxe especial para acessar átomos como chaves:

map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
map.hello
"world"
Outra propriedade interessante de mapas é que eles têm sua própria sintaxe para atualizar e acessar átomos como chaves:

map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
%{map | foo: "baz"}
%{foo: "baz", hello: "world"}
Nota: esta sintaxe funciona apenas para atualizar uma chave que já existe no mapa! Se a chave não existir, um KeyError será gerado.

Para criar uma nova chave, use Map.put/3

map = %{hello: "world"}
%{hello: "world"}
%{map | foo: "baz"}
** (KeyError) key :foo not found in: %{hello: "world"}
    (stdlib) :maps.update(:foo, "baz", %{hello: "world"})
    (stdlib) erl_eval.erl:259: anonymous fn/2 in :erl_eval.expr/5
    (stdlib) lists.erl:1263: :lists.foldl/3
Map.put(map, :foo, "baz")
%{foo: "baz", hello: "world"}




https://elixirschool.com/pt/lessons/basics/collections


## Como usar funções

https://elixirschool.com/pt/lessons/basics/functions

Dar exemplos de algumas funções. 

String.

Aridade.

String.capitalize("wesLeY")

String.upcase("wesLeY")


String.duplicate("SIM ", 30)

String.upcase/1 String.upcase/2

String.duplicate/2


## Como definir módulos e funções

## Resolver um problema

Qual? Quais?
