## Elixir e Erlang

https://dev.to/elixir_utfpr/o-que-e-o-ecossistema-de-erlang-3km

## O que é um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profissão. O salário mensal de Maria é R$ 5.050,55.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Você deve ter percebido que, ao escrever o nome e a profissão, usamos aspas. E, ao escrever o salário, usamos "." (ponto) no lugar da "," (vírgula) e não colocamos a moeda ("R$"). Explicaremos isto depois.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima têm tipos diferentes.

## Quais são os tipos de valores?

### Tipos Básicos

https://elixirschool.com/pt/lessons/basics/basics#tipos-b%C3%A1sicos-3

### Inteiros
```elixir
iex> 255
255
```
O suporte para números binários, octais e hexadecimais também estão inclusos:
```elixir
iex> 0b0110
6
iex> 0o644
420
iex> 0x1F
31
```

### Pontos Flutuantes
Em Elixir, os números de ponto flutuante requerem um decimal depois de pelo menos um dígito; estes possuem uma precisão de 64 bits e suportam e para números exponenciais:
```elixir
iex> 3.14
 3.14
iex> .14
** (SyntaxError) iex:2: syntax error before: '.'
iex> 1.0e-10
1.0e-10
```

### Booleanos
Elixir suporta true e false como booleanos; todo valor é verdadeiro com exceção de false e nil:
```elixir
iex> true
true
iex> false
false
```

### Átomos
Um átomo é uma constante cujo o nome é seu valor. Se está familiarizado com Ruby, estes são equivalentes aos símbolos:
```elixir
iex> :foo
:foo
iex> :foo == :bar
false
```
Booleanos true e false também são os átomos :true e :false, respectivamente.
```elixir
iex> is_atom(true)
true
iex> is_boolean(:true)
true
iex> :true === true
true
```
Nomes de módulos em Elixir também são átomos. MyApp.MyModule é um átomo válido, mesmo se tal módulo ainda não tenha sido declarado.
```elixir
iex> is_atom(MyApp.MyModule)
true
```
Átomos também são usados para referenciar módulos de bibliotecas Erlang, incluindo as bibliotecas integradas.
```elixir
iex> :crypto.strong_rand_bytes 3
<<23, 104, 108>>
```
### Strings
As strings em Elixir são codificadas em UTF-8 e são representadas com aspas duplas:
```elixir
iex> "Hello"
"Hello"
iex> "dziękuję"
"dziękuję"
```
As strings suportam quebras de linha e caracteres de escape:
```elixir
iex> "foo
...> bar"
"foo\nbar"
iex> "foo\nbar"
"foo\nbar"
```

## O que é o casamento de padrões?

Pattern matching é uma poderosa parte de Elixir que nos permite procurar padrões simples em valores, estruturas de dados, e até funções. Nesta lição iremos começar a ver como pattern matching é usado.
### Operador Match
Você está preparado para ficar um pouco confuso? Em Elixir, o operador = é na verdade o nosso operador match, comparável ao sinal de igualdade da matemática. Quando usado, a expressão inteira se torna uma equação e faz com que Elixir combine os valores do lado esquerdo com os valores do lado direito da expressão. Se a comparação for bem sucedida, o valor da equação é retornado. Se não, um erro é lançado. Vejamos a seguir:
```elixir
iex> x = 1
1
```
Agora vamos tentar a simples correspondência:
```elixir
iex> 1 = x
1
iex> 2 = x
** (MatchError) no match of right hand side value: 1
```
Vamos tentar isso com algumas das coleções que nós conhecemos:
```elixir
# Listas
iex> list = [1, 2, 3]
[1, 2, 3]
[1, 2, 3] = list
[1, 2, 3]
[] = list
** (MatchError) no match of right hand side value: [1, 2, 3]

iex> [1 | tail] = list
[1, 2, 3]
iex> tail
[2, 3]
iex> [2 | _] = list
** (MatchError) no match of right hand side value: [1, 2, 3]

# Tuplas
iex> {:ok, value} = {:ok, "Successful!"}
{:ok, "Successful!"}
iex> value
"Successful!"
iex> {:ok, value} = {:error}
** (MatchError) no match of right hand side value: {:error}
```
### Operador Pin
Acabamos de aprender que o operador match manuseia atribuições quando o lado esquerdo da associação é uma variável. Em alguns casos este comportamento de reassociação de variável é algo não desejável. Para estas situações, nós temos o operador pin:^.
Quando fixamos a variável em associação ao valor existente ao invés de reassociar a um novo valor. Vamos ver como isso funciona:
```elixir
iex> x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2
iex> {x, ^x} = {2, 1}
{2, 1}
iex> x
2
```

Elixir 1.2 introduziu suporte para pins em chaves de mapas e cláusulas de função:
```elixir
iex> key = "hello"
"hello"
iex> %{^key => value} = %{"hello" => "world"}
%{"hello" => "world"}
iex> value
"world"
iex> %{^key => value} = %{:hello => "world"}
** (MatchError) no match of right hand side value: %{hello: "world"}
```
Um exemplo do uso do pin em uma cláusula de função:
```elixir
iex> greeting = "Hello"
"Hello"
iex> greet = fn
...>  (^greeting, name) -> "Hi #{name}"
...>  (greeting, name) -> "#{greeting}, #{name}"
...> end
#Function<12.54118792/2 in :erl_eval.expr/5>
iex> greet.("Hello", "Sean")
"Hi Sean"
iex> greet.("Mornin'", "Sean")
"Mornin', Sean"
iex> greeting
"Hello"
```
Note que no exemplo "Mornin'", a reassociação de greeting para "Mornin'" só acontece dentro de uma função. Fora da função, greeting continua sendo "Hello".

https://elixirschool.com/pt/lessons/basics/pattern_matching

## O que é uma variável?

## Como atribuir um valor a uma variável?

## Quais são os tipos de valores que são composições de outros tipos?

https://elixirschool.com/pt/lessons/basics/collections

### Casamento de padrões com coleções

https://elixirschool.com/pt/lessons/basics/pattern_matching

## Como usar funções

https://elixirschool.com/pt/lessons/basics/functions

Dar exemplos de algumas funções. 

String.

Aridade.

String.capitalize("wesLeY")

String.upcase("wesLeY")


String.duplicate("SIM ", 30)

String.upcase/1 String.upcase/2

String.duplicate/2


## Como definir módulos e funções

## Resolver um problema

Qual? Quais?
