# Learn 4 Elixir - Capítulo 1

## Introdução

Neste capítulo iremos apresentar a você, brevemente, a linguagem de programação Elixir. Assim como nos demais capítulos, você deve acompanhar este capítulo no [Livebook](https://livebook.dev/).

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter1.livemd)

## Elixir

Elixir é uma linguagem criada pelo brasileiro [José Valim](https://github.com/josevalim). O projeto começou em 2011, enquanto Valim fazia parte da empresa [Plataformatec](https://plataformatec.com/), da qual ele era um dos sócios. Em 24 de maio de 2012 foi lançada a versão 0.5 de Elixir, a primeira versão, segundo Valim, com as características de Elixir atual. Por esta razão o [aniversário de 10 anos de Elixir foi comemorado em 24 de maio de 2022](http://adolfont.github.io/service/events/10YearsOfElixir/).

De acordo com sua própria definição, o Elixir é "uma linguagem dinâmica e funcional, projetada para construir aplicações escaláveis e sustentáveis". A linguagem foi desenvolvida para ser executada sobre a máquina virtual de Erlang (chamada de BEAM), com o objetivo de ampliar a produtividade e extensibilidade do ecossistema da linguagem [Erlang](https://www.erlang.org/), criada na década de 80. O ecossistema de Erlang refere-se ao conjunto de tecnologias, ferramentas, bibliotecas e comunidades relacionadas a Erlang. Erlang é uma linguagem de programação funcional, concorrente e tolerante a falhas.

O ecossistema de Erlang é conhecido por sua força em sistemas distribuídos e de tempo real flexível, especialmente em aplicações de telecomunicações e comunicações em larga escala. [WhatsApp é um exemplo de empresa que usa Erlang em produção](https://www.erlang-solutions.com/blog/20-years-of-open-source-erlang-openerlang-interview-with-anton-lavrik-from-whatsapp/). Erlang oferece recursos para lidar com concorrência, escalabilidade e resiliência, tornando-a adequada para sistemas altamente disponíveis e que exigem baixa latência.

### Caso de Uso de Elixir

Um dos casos mais conhecidos de empresa que usa Elixir em produção como uma de suas principais linguagens é Discord. Em 2019, a empresa escreveu em seu blog o post ["Usando Rust para escalar Elixir para 11 milhões de usuários concorrentes"](https://discord.com/blog/using-rust-to-scale-elixir-for-11-million-concurrent-users). Segundo a equipe de desenvolvedores, a escolha pelo Elixir veio desde o início, quando buscavam criar um sistema altamente concorrente em tempo real — o protótipo do Discord foi programado em Elixir.

Outros exemplos de empresas que usam Elixir em produção podem ser encontrados [seção Cases da página da linguagem Elixir](https://elixir-lang.org/cases.html).

*Agora vamos começar a aprender Elixir!*

## O que é um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profissão. O salário mensal de Maria é R$ 5.050,55. Clique em _Evaluate_ para avaliar cada um dos valores. O botão _Evaluate_ aparece quando você passa o _mouse_ em cima do canto superior esquerdo da caixa onde fica o valor. Depois da primeira avaliação, o botão se torna _Reevaluate_.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Quando executamos valores o Elixir nos retorna exatamente esse valor como resultado. Isso acontece porque os valores são constantes e imutáveis. Quando avaliados, retornam a si mesmos uma vez que nenhuma transformação é aplicada.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima têm tipos diferentes.

## Quais são os tipos de valores?

Vamos começar nossa exploração pelos tipos de dados fundamentais na programação, que formam a base sobre a qual construímos a lógica e a estrutura de nossos programas. Os tipos básicos que abordaremos incluem: Números Inteiros, Números de Ponto Flutuante, Valores Lógicos (Booleanos), Átomos e Cadeias de Caracteres (_Strings_).

## Números Inteiros

Abaixo você pode  ver e avaliar vários números inteiros. Números inteiros são usados para representar valores númericos que não precisam de casas decimais.

```elixir
10
```

Observe, no último exemplo, que você pode usar o "_" como separador.

```elixir
654_677_888_788_899
```

Da mesma forma é possível representar números negativos utilizando sinal.

```elixir
-5_323_456_546_346
```

Além disso é possível representar números em outras bases como binário (prefixando com **0b**), octal (prefixando com **0o**) e hexadecimal (prefixando com **0x**).

```elixir
0b101010
```

```elixir
0o52
```

```elixir
0x2A
```

## Números de Ponto Flutuante

Números de ponto flutuante exigem um ponto decimal depois de pelo menos um dígito. Eles possuem precisão de 64 bits e suportam "e" para números exponenciais.

Avalie os exemplos abaixo para ver o que acontece!

```elixir
1.618
```

```elixir
.14
```

```elixir
1.0e-10
```

```elixir
1.234e3
```

> Em qual dos exemplos acima aconteceu um erro? Por quê?

## Átomos

Em Elixir, um átomo é uma espécie de palavra-chave constante que tem um nome que é igual ao seu valor. Imagine um átomo como uma etiqueta com uma palavra que representa algo específico. A coisa interessante sobre os átomos em Elixir é que eles sempre começam com dois pontos (:).

```elixir
:atomo
```

```elixir
:idade
```

```elixir
:peso
```

## Valores Lógicos (Booleanos)

Em Elixir, os valores lógicos são como interruptores que podem estar ligados (verdadeiros) ou desligados (falsos). Elixir usa dois átomos especiais para representar esses valores: `:true` para verdadeiro e `:false` para falso.

Porém esses átomos especiais são tão importantes e bem conhecidos que você não precisa colocar dois pontos antes deles como você faria com outros átomos. Em vez disso, você pode simplesmente usar `true` para representar verdadeiro e `false` para representar falso.

```elixir
is_atom(true)
```

Se você escrever `true` em Elixir, isso significa "verdadeiro" e representa um valor lógico que está ligado ou verdadeiro.

```elixir
true
```

Se você escrever `false` em Elixir, isso significa "falso" e representa um valor lógico que está desligado ou falso.

```elixir
false
```

## Cadeias de Caracteres (Strings)

Uma **cadeia de caracteres**, que é chamada de **"string"**, é basicamente uma sequência de letras, números, símbolos ou até mesmo emojis. Para indicar que algo é uma string em Elixir, você a envolve com aspas duplas (`"`). Isso ajuda o Elixir a entender que tudo dentro das aspas é uma única string.

```elixir
"Olá, Elixir!"
```

As strings em Elixir são inteligentes e podem conter caracteres especiais, como acentos em letras ou até mesmo emojis. O Elixir usa a codificação UTF-8, o que significa que é possível representar uma ampla variedade de caracteres de diferentes idiomas e símbolos.

```elixir
"José Valim é o criador de Elixir!! 🎉🎉🎉 Ele é brasileiro!!! 🇧🇷🇧🇷🇧🇷"
```

Você pode até mesmo criar strings que se estendem por várias linhas. Para fazer isso, você usa três aspas duplas no início e no final da string, assim: `"""`.

```elixir
"""
Olá, pessoas!
Este é o Learn4Elixir da Universidade Brasileira Live.
Em Elixir você pode ter uma string com várias linhas!
"""
```

## Verificando Tipos

Existem diversas funções que nos permitem verificar o tipo de um valor ou expressão. O mais comum é quando queremos saber o tipo de um valor usar uma função **is_** (É? em inglês) seguida do tipo que queremos saber, como vimos antes **is_atom** checa se o valor é um átomo.

```elixir
is_atom(:um_atomo)
```

Existe uma função similar para cada tipo, como vamos ver.

```elixir
is_integer(1233)
```

```elixir
is_integer(false)
```

```elixir
is_float(1)
```

```elixir
is_float(1.0)
```

```elixir
is_number(1)
```

```elixir
is_number(1.9)
```

```elixir
is_atom(:peso)
```

```elixir
is_atom(10)
```

```elixir
is_atom(true)
```

```elixir
is_atom(45.4)
```

```elixir
is_boolean(true)
```

```elixir
is_boolean(false)
```

```elixir
is_boolean(0)
```

```elixir
is_boolean(nil)
```

Porém, a função para verificar _strings_ diferente das outras se chama _is_binary_.

```elixir
is_binary("UBL")
```

```elixir
is_binary(true)
```

```elixir
is_binary("🎉🎉🎉")
```

## Expressões

Agora que já estamos familiarizados com os tipos de dados em Elixir, é hora de aprender sobre expressões. Expressões são maneiras de combinar e manipular esses tipos de dados para realizar tarefas em nosso código.

<!-- livebook:{"break_markdown":true} -->

Pense em expressões como pequenos blocos de construção que nos permitem fazer coisas úteis. Por exemplo, podemos usar operadores, que são como ferramentas especiais, para realizar cálculos e comparações. No entanto, vale ressaltar que os operadores em Elixir são, na verdade, funções especiais que realizam operações específicas.

```elixir
2 + 3
```

```elixir
4 - 5
```

```elixir
4 * 80
```

```elixir
4 / 3
```

> Observe que, no exemplo acima, apesar de os operandos serem números inteiros, o resultado foi um número de ponto flutuante.

<!-- livebook:{"break_markdown":true} -->

Além dos operadores matemáticos temos também outros operadores. Por exemplo, temos os operadores lógicos que usamos para fazer operações com valores lógicos (booleanos), são eles `and`, `or` e `not`.

<!-- livebook:{"break_markdown":true} -->

`and`: Este operador retorna `true` se **ambos** os operandos forem verdadeiros. Caso contrário, retorna `false`. Por exemplo, `true and false` retornará `false`.

```elixir
true and false
```

`or`: Este operador retorna `true` se **qualquer um** dos operandos for verdadeiro. Caso contrário, retorna `false`. Por exemplo, `true or false` retornará `true`.

```elixir
false or true
```

`not`: Este é um operador de negação. Ele inverte o valor do operando. Se o operando for `true`, ele retornará `false` e vice-versa. Por exemplo, `not true` retornará `false`.

```elixir
not false
```

**Concatenação de Strings**: Em Elixir, usamos o operador `<>` para concatenar (ou seja, juntar) duas strings.

```elixir
"UBL" <> " " <> "é legal!"
```

```elixir
"https://" <> "ulivre.dev"
```

A interpolação de strings permite que você insira valores de variáveis ou expressões dentro de uma string. Em Elixir, usamos `#{}` para interpolação de strings.

```elixir
"Onde você estuda? Eu estudo na #{"UBL"}!"
```

```elixir
"Eu tenho #{25} anos de idade."
```

Observe que não apresentamos nenhuma operação com átomos, exceto quando estes são valores lógicos.

## Casamento de Padrões (Pattern Matching)

Ao falar de casamento de padrões, precisamos falar de variáveis. Uma variável precisa ter um nome, que geralmente começa com uma letra mínúscula (a convenção 'camel_case' é bastante utilizada), e precisa ser atribuída a um valor para poder ser avaliada. Por exemplo, tente avaliar a variável 'nome' abaixo e vai acontecer o erro "variável nçao definida" (em inglês, "undefined variable").

```elixir
nome
```

Mas se você usar o operador de casamento de padrões, cujo símbolo é o '=', você pode casar o padrão "UBL", por exemplo, com a variável 'nome' e assim atribuir "UBL" a 'nome'. Avalie o código abaixo:

```elixir
nome = "UBL"
```

Observe que o retorno da expressão (toda expressão em Elixir retorna algo, se não ocporrer nenhum erro) é o valor que, após o casamento de padrões, está dos dois lados do operador '='.

<!-- livebook:{"break_markdown":true} -->

Se você agora pedir para avaliar 'nome', o resultado será diferente.

```elixir
nome
```

Apesar do símbolo do casamento de padrões ser '=', os lados esquerdo e direito de um casamento de padrões têm "poderes" diferentes. No exemplo acima, vimos como atribuir um valor à variável 'nome'. Só pudemos fazer isso porque 'nome' estava no lado esquerdo. Se estivesse no lado direito (ver o exemplo parecido seguinte), não funcionaria. Ou seja, o lado esquerdo "tem mais poder" do que o lado direito.

```elixir
10 = idade
```

Porém, uma vez que uma variável já esteja atribuída, é possível usá-la do lado direito. Veja o exemplo abaixo.

```elixir
"UBL" = nome
```

O exemplo acima é importante para deixar claro que o casamento de padrões não é uma simples atribuição de valor a variável.

<!-- livebook:{"break_markdown":true} -->

Os demais exemplos de casamento de padrões só fazem sentido se você conhecer as estrturas de dados compostas (as coleções).

## Listas

Coleções são estruturas de dados que contém zero ou mais valores. O tipo de coleção que provavelmente é o mais usado em Elixir são as listas. Uma lista pode ser vazia ou conter 1 ou mais elementos. Não vamos discutir detalhes de como listas são implementadas em Elixir aqui. Apenas mostraremos como são representadas e como fazer casamento de padrões com elas.

```elixir
# Lista Vazia
[]
```

No exemplo acima você vê uma lista vazia e também como escrever um comentário de linha em Elixir: tudo que vier depois do '#' é um comentário.

```elixir
# lista contendo um elemento
[1]
```

```elixir
# lista contendo dois elementos
[3, 45]
```

```elixir
# lista contendo 3 elementos
[45, 78, 21]
```

A partir dos exemplos acima, você já percebeu que as listas começam com '[', terminam com ']' os valores são separados por vírgulas. Mais alguns exemplos.

```elixir
# lista com valores de diferentes tipos.
[1, "Casa", :idade]
```

```elixir
# lista contendo outra lista
[1, [2, 45], 3]
```

Agora vamos ver exemplos de casamento de padrões com listas.

```elixir
[cabeca | cauda] = [1, 3, 2]
```

```elixir
cabeca
```

```elixir
cauda
```

```elixir
[primeiro, segundo | resto] = [45, 67, 784, 3453]
```

```elixir
primeiro
```

```elixir
segundo
```

```elixir
resto
```

O exemplo abaixo não dá erro pois no final de toda lista há uma lista vazia.

```elixir
[cabeca | cauda] = [78678]
```

```elixir
cabeca
```

```elixir
cauda
```

Mas o exemplo abaixo dá erro.

```elixir
[cabeca | cauda] = []
```

No casamento de padrões, você pode usar o operador '_', que alguns chamam de "coringa", para ignorar algo.

```elixir
[cabeca | _] = [646, 345, 345]
```

```elixir
cabeca
```

```elixir
_
```

Nada é atribuído a '_'.

<!-- livebook:{"break_markdown":true} -->

Veremos depois como utilizar '_' com tuplas.

<!-- livebook:{"break_markdown":true} -->

Uma observação importante, e que está relacionada com a forma com que listas são implemantadas, é que as listas devem crescer na cabeça. Ou seja, se eu for colocar um novo elemento, devo colocá-lo como primeiro elemento (mais à esquerda). Para isso, eu posso usar o operador '|' como nos exemplos abaixo.

```elixir
[1 | [3, 4]]
```

```elixir
[1 | []]
```

```elixir
[2, 3, 4 | [6, 7, 8, 9]]
```

Apenas tenha cuidado para não gerar listas impóprias! Depois do '|' deve vir uma lista.

```elixir
[1 | 2]
```

É possível, mas não recomendável se a segunda lista for grande, concatenar listas. O operador de concatenação é o '++/2'.

```elixir
[1, 3, 56] ++ [34, 560, 8]
```

Uma pequena nota sobre o formato de nome '++/2' usado acima. Em Elixir, o nome de uma função ou operador tem dois componentes: o nome em si (neste caso ++) e sua aridade. Aridade é informação essencial quando se fala sobre código Elixir. A aridade indica o número de argumentos que uma dada função ou operador aceita (dois, neste nosso exemplo). Nome e aridade são combinados com uma barra.

```elixir
# subtração de listas, operador '--/2'
[1, 2, 3] -- [1, 3]
```

```elixir
[1, 2, 2, 3, 2, 3] -- [1, 2, 3, 2]
```

## Tuplas

Uma tupla é uma coleção ordenada de elementos. Parece um pouco com uma lista, mas seu casamento de padrões trabalha com um número fixo de elementos, diferente das listas, que permitem o casamento de padrões sem que se saiba o número exato de seus elementos. As tuplas são definidas usando chaves '{', '}' e seus valores são separados por vírgulas..

```elixir
# tupla vazia
{}
```

```elixir
{1}
```

```elixir
{:nome, "João"}
```

```elixir
{:nome, "Maria", :idade, 10}
```

Após ver os exemplos acima, vamos ver como fazer casamento de padrões com tuplas. Suponha que você tem uma vaiável 'pessoa', como abaixo:

```elixir
pessoa = {:nome, "Maria", :idade, 10}
```

E suponha que eu, sabendo a estrutura da tupla pessoa, queira apenas saber o nome da pessoa. Basta fazer:

```elixir
{:nome, nome, _, _} = pessoa
```

```elixir
nome
```

O mesmo poderia ser feito para idade.

```elixir
{_, _, :idade, idade} = pessoa
```

```elixir
idade
```

Ou para os dois ao mesmo tempo.

```elixir
{:nome, nome, :idade, idade} = pessoa
```

```elixir
{nome, idade}
```

Veja que acima nós construímos uma tupla a partir dos resultados do casamento de padrões.

## Exemplos de casamento de padrões um pouco mais complexos

```elixir
[_, num, {:nome, name, :ano, year} | _] = [1, 3, {:nome, "pxto", :ano, 1978}, [45, 67]]
```

```elixir
{num, name, year}
```

## Outras coleções

Existem outros tipos de coleções em Elixir, mas eles estão foram do escopo deste documento.

## Exercício

Qual? Quais?

## Links

Se você quiser saber mais, recomendamos abaixo alguns links que podem ser úteis:

* [Elixir School](https://elixirschool.com/pt) - Site que contém várias "lições" em português.
* [Livros e outros recursos de aprendizagem](https://elixir-lang.org/learning.html)
* [Elixir Brasil - Comunidade no Telegram](https://t.me/elixirbr)
* [Elixir em Foco - podcast em português](https://www.elixiremfoco.com/)
