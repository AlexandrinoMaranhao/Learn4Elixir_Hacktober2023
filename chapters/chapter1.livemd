## Elixir e Erlang
### Historia de Erlang
BEAM, a máquina virtual de Erlang. Por que a máquina virtual de Erlang se chama BEAM e não EVM?

Por motivos históricos explicados em A history of Erlang, de Joe Armstrong. Simplificando: por volta de 1990 havia a JAM, Joe Abstract Machine, onde "Joe" refere-se a Joe Armstrong, um dos criadores da linguagem. Em 1993 a equipe do Erlang decidiu criar uma versão mais eficiente da máquina virtual de Erlang. Bogumil (Bogdan) Hausman foi o principal criador desta linguagem e o nome inicial dela era Turbo Erlang. Mas como Turbo era uma marca da empresa Borland, renomearam a máquina para BEAM: Bogdan's Erlang Abstract Machine.


O ecossistema de Erlang refere-se ao conjunto de tecnologias, ferramentas, bibliotecas e comunidades relacionadas à linguagem de programação Erlang. Erlang é uma linguagem de programação funcional, concorrente e tolerante a falhas, desenvolvida pela Ericsson no final dos anos 80.

O ecossistema de Erlang é conhecido por sua força em sistemas distribuídos e de tempo real, especialmente em aplicativos de telecomunicações e comunicações em larga escala. Ele oferece recursos poderosos para lidar com concorrência, escalabilidade e resiliência, tornando-o adequado para sistemas altamente disponíveis e que exigem baixa latência.

### Alguns exemplos dentro de Erlang
Dentro do ecossistema de Erlang, existem várias ferramentas e bibliotecas notáveis que complementam a linguagem. Alguns exemplos incluem:

OTP (Open Telecom Platform): É um conjunto de bibliotecas e frameworks que fornecem abstrações e componentes reutilizáveis para o desenvolvimento de sistemas distribuídos robustos. O OTP inclui o "Supervisor", que gerencia a tolerância a falhas, e o "GenServer", que permite criar processos concorrentes.

Cowboy: É um servidor web assíncrono em Erlang, projetado para lidar com alto tráfego e requisitos de baixa latência. Ele fornece um ambiente para criar aplicativos web escaláveis e de alto desempenho.

RabbitMQ: É um sistema de mensagens assíncronas baseado em Erlang. Ele fornece uma plataforma de mensagens robusta e escalável para integração de sistemas distribuídos.

Elixir: Embora tecnicamente não seja parte do ecossistema de Erlang, vale a pena mencionar o Elixir. Ele é uma linguagem de programação funcional construída em cima da máquina virtual Erlang (BEAM). Elixir aproveita os recursos do ecossistema de Erlang, mas oferece uma sintaxe mais moderna e uma abordagem mais amigável para a programação.

Além disso, o ecossistema de Erlang é suportado por uma comunidade ativa de desenvolvedores, com conferências, fóruns online e recursos educacionais disponíveis para compartilhar conhecimento e promover a colaboração.

Em resumo, o ecossistema de Erlang é um conjunto de recursos, ferramentas e comunidades relacionadas à linguagem de programação Erlang, que enfatiza a construção de sistemas distribuídos, tolerantes a falhas e de alto desempenho.

### Historia de Elixir
Elixir, é uma linguagem de berço brasileiro, criada, desenvolvida e mantida por José Valim, em 2011, junto com o núcleo de Desenvolvimento e Pesquisa (R&D) da Plataformatec.

De acordo com sua própria definição, o Elixir é "uma linguagem dinâmica e funcional, desenhada para construir aplicações escaláveis e sustentáveis".

A linguagem foi desenvolvida para ser executada sobre a máquina virtual Erlang VM, com o objetivo de ampliar a produtividade e extensibilidade do ecossistema da linguagem Erlang, criada na década de 80 para múltiplos fins.

### Promessas vitais

Um dos casos de maior sucesso de execução do Elixir, dentro do ecossistema web, é a plataforma de comunicação Discord.

Segundo a equipe de desenvolvedores, a escolha pelo Elixir veio desde o início, quando miravam em criar um sistema altamente concorrente em tempo real — o protótipo do Discord foi programado em Elixir, apostando nas promessas que a linguagem fazia ao rodar na máquina virtual.

Para eles, a "promessa Elixir" era simples: "acessar o poder da Erlang VM por meio de uma linguagem muito mais moderna e amigável ao usuário.

## O que é um valor?

Um valor representa um dado do mundo. Por exemplo, 10 pode representar a idade de uma pessoa. Maria o nome desta pessoa e professora sua profissão. O salário mensal de Maria é R$ 5.050,55.

```elixir
10
```

```elixir
"Maria"
```

```elixir
"professora"
```

```elixir
5050.55
```

Você deve ter percebido que, ao escrever o nome e a profissão, usamos aspas. E, ao escrever o salário, usamos "." (ponto) no lugar da "," (vírgula) e não colocamos a moeda ("R$"). Explicaremos isto depois.

<!-- livebook:{"break_markdown":true} -->

Mas antes de mais nada temos que observar que os dados acima têm tipos diferentes.

## Quais são os tipos de valores?

### Tipos Básicos

### Inteiros
```elixir
iex> 255
255
```
O suporte para números binários, octais e hexadecimais também estão inclusos:
```elixir
iex> 0b0110
6
iex> 0o644
420
iex> 0x1F
31
```

### Pontos Flutuantes
Em Elixir, os números de ponto flutuante requerem um decimal depois de pelo menos um dígito; estes possuem uma precisão de 64 bits e suportam e para números exponenciais:
```elixir
iex> 3.14
 3.14
iex> .14
** (SyntaxError) iex:2: syntax error before: '.'
iex> 1.0e-10
1.0e-10
```

### Booleanos
Elixir suporta true e false como booleanos; todo valor é verdadeiro com exceção de false e nil:
```elixir
iex> true
true
iex> false
false
```

### Átomos
Um átomo é uma constante cujo o nome é seu valor. Se está familiarizado com Ruby, estes são equivalentes aos símbolos:
```elixir
iex> :foo
:foo
iex> :foo == :bar
false
```
Booleanos true e false também são os átomos :true e :false, respectivamente.
```elixir
iex> is_atom(true)
true
iex> is_boolean(:true)
true
iex> :true === true
true
```
Nomes de módulos em Elixir também são átomos. MyApp.MyModule é um átomo válido, mesmo se tal módulo ainda não tenha sido declarado.
```elixir
iex> is_atom(MyApp.MyModule)
true
```
Átomos também são usados para referenciar módulos de bibliotecas Erlang, incluindo as bibliotecas integradas.
```elixir
iex> :crypto.strong_rand_bytes 3
<<23, 104, 108>>
```
### Strings
As strings em Elixir são codificadas em UTF-8 e são representadas com aspas duplas:
```elixir
iex> "Hello"
"Hello"
iex> "dziękuję"
"dziękuję"
```
As strings suportam quebras de linha e caracteres de escape:
```elixir
iex> "foo
...> bar"
"foo\nbar"
iex> "foo\nbar"
"foo\nbar"
```

## O que é o casamento de padrões?

Pattern matching é uma poderosa parte de Elixir que nos permite procurar padrões simples em valores, estruturas de dados, e até funções. Nesta lição iremos começar a ver como pattern matching é usado.
### Operador Match
Você está preparado para ficar um pouco confuso? Em Elixir, o operador = é na verdade o nosso operador match, comparável ao sinal de igualdade da matemática. Quando usado, a expressão inteira se torna uma equação e faz com que Elixir combine os valores do lado esquerdo com os valores do lado direito da expressão. Se a comparação for bem sucedida, o valor da equação é retornado. Se não, um erro é lançado. Vejamos a seguir:
```elixir
iex> x = 1
1
```
Agora vamos tentar a simples correspondência:
```elixir
iex> 1 = x
1
iex> 2 = x
** (MatchError) no match of right hand side value: 1
```
Vamos tentar isso com algumas das coleções que nós conhecemos:
```elixir
# Listas
iex> list = [1, 2, 3]
[1, 2, 3]
[1, 2, 3] = list
[1, 2, 3]
[] = list
** (MatchError) no match of right hand side value: [1, 2, 3]

iex> [1 | tail] = list
[1, 2, 3]
iex> tail
[2, 3]
iex> [2 | _] = list
** (MatchError) no match of right hand side value: [1, 2, 3]

# Tuplas
iex> {:ok, value} = {:ok, "Successful!"}
{:ok, "Successful!"}
iex> value
"Successful!"
iex> {:ok, value} = {:error}
** (MatchError) no match of right hand side value: {:error}
```
### Operador Pin
Acabamos de aprender que o operador match manuseia atribuições quando o lado esquerdo da associação é uma variável. Em alguns casos este comportamento de reassociação de variável é algo não desejável. Para estas situações, nós temos o operador pin:^.
Quando fixamos a variável em associação ao valor existente ao invés de reassociar a um novo valor. Vamos ver como isso funciona:
```elixir
iex> x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2
iex> {x, ^x} = {2, 1}
{2, 1}
iex> x
2
```

Elixir 1.2 introduziu suporte para pins em chaves de mapas e cláusulas de função:
```elixir
iex> key = "hello"
"hello"
iex> %{^key => value} = %{"hello" => "world"}
%{"hello" => "world"}
iex> value
"world"
iex> %{^key => value} = %{:hello => "world"}
** (MatchError) no match of right hand side value: %{hello: "world"}
```
Um exemplo do uso do pin em uma cláusula de função:
```elixir
iex> greeting = "Hello"
"Hello"
iex> greet = fn
...>  (^greeting, name) -> "Hi #{name}"
...>  (greeting, name) -> "#{greeting}, #{name}"
...> end
#Function<12.54118792/2 in :erl_eval.expr/5>
iex> greet.("Hello", "Sean")
"Hi Sean"
iex> greet.("Mornin'", "Sean")
"Mornin', Sean"
iex> greeting
"Hello"
```
Note que no exemplo "Mornin'", a reassociação de greeting para "Mornin'" só acontece dentro de uma função. Fora da função, greeting continua sendo "Hello".

## O que é uma variável?

Em Elixir, uma variável é um nome que você associa a um valor ou a uma expressão. As variáveis são usadas para armazenar dados que podem ser usados posteriormente em um programa. Aqui estão algumas características importantes das variáveis em Elixir:

Padrão de Imutabilidade: Em Elixir, as variáveis são imutáveis, o que significa que uma vez que você atribui um valor a uma variável, não pode alterá-lo. Em vez disso, quando você "altera" o valor de uma variável, na verdade está criando uma nova variável com um novo valor. Isso é fundamental para o paradigma funcional de Elixir.

Ámbito de Variável: As variáveis têm um escopo local. Isso significa que uma variável definida em uma função ou em um bloco de código só é acessível dentro desse escopo. Isso ajuda a evitar conflitos de nomes de variáveis em partes diferentes de um programa.

Convenções de Nomenclatura: Em Elixir, as variáveis são geralmente escritas em letras minúsculas e podem conter letras, números e sublinhados. Por exemplo, nome, idade, minha_variavel, etc.

Aqui está um exemplo simples de como criar e usar variáveis em Elixir:
```elixir
# Definindo uma variável
nome = "João"

# Usando a variável
IO.puts("Olá, #{nome}!")

# Tentativa de reatribuir a variável (isso não funcionará)
nome = "Maria"  # Isso cria uma nova variável chamada "nome" com o novo valor, não modifica a variável original
```
No exemplo acima, criamos uma variável chamada nome e a utilizamos em uma saída de texto. Quando tentamos atribuir um novo valor a nome, na verdade estamos criando uma nova variável nome com o valor "Maria", mas a variável original nome permanece inalterada.

Em resumo, as variáveis em Elixir são usadas para armazenar valores imutáveis ​​e são uma parte fundamental da programação funcional em Elixir.

## Como atribuir um valor a uma variável?

Em Elixir, você pode atribuir um valor a uma variável usando o operador =. Aqui está um exemplo simples de como fazer isso:


```elixir
# Definindo uma variável chamada "nome" com o valor "João"
nome = "João"

# Usando a variável
IO.puts("Olá, #{nome}!")
```
Neste exemplo, estamos definindo uma variável chamada nome e atribuindo a ela o valor "João". Em seguida, usamos a variável nome em uma saída de texto. A variável nome agora contém o valor "João" e pode ser usada em qualquer lugar dentro do escopo em que foi definida.

Lembre-se de que, em Elixir, as variáveis são imutáveis, o que significa que, uma vez que você atribui um valor a uma variável, não pode alterá-lo. Se você tentar atribuir um novo valor à mesma variável, na verdade estará criando uma nova variável com o novo valor, como mencionado anteriormente.

## Quais são os tipos de valores que são composições de outros tipos?

https://elixirschool.com/pt/lessons/basics/collections


## Como usar funções

https://elixirschool.com/pt/lessons/basics/functions

Dar exemplos de algumas funções. 

String.

Aridade.

String.capitalize("wesLeY")

String.upcase("wesLeY")


String.duplicate("SIM ", 30)

String.upcase/1 String.upcase/2

String.duplicate/2


## Como definir módulos e funções

## Resolver um problema

Qual? Quais?
