## Capitulo 4
Neste Capitulo você irá aprender sobre: Data e Tempo, Processos em Elixir e Agentes.


## Data e Tempo 
### Time

O Elixir tem alguns módulos que trabalham com tempo. Ainda que precise ser notado que essa funcionalidade é limitada para trabalhar com fuso horário UTC.

Vamos começar pegando o tempo atual:

```elixir
iex> Time.utc_now
~T[19:39:31.056226]
```

Note que nós vamos ter um sigil que pode ser usado para criar uma struct Time também:

```elixir
iex> ~T[19:39:31.056226]
~T[19:39:31.056226]
```

Você pode aprender mais sobre sigil na lição sobre sigils. É fácil acessar partes desta struct:

```elixir
iex> t = ~T[19:39:31.056226]
~T[19:39:31.056226]
iex> t.hour
19
iex> t.minute
39
iex> t.day
** (KeyError) key :day not found in: ~T[19:39:31.056226]
```

Mas há uma pegadinha: como você pode ter notado, essa struct contém apenas tempo de um dia, dados de dia/mês/ano não estão presentes.

### Date
Ao contrário do Time, a struct Date tem as informações sobre a data sem nenhuma informação sobre o tempo.

```elixir
iex> Date.utc_today
~D[2028-10-21]
```

Mas ele tem algumas funções úteis para trabalhar com datas:

```elixir
iex> {:ok, date} = Date.new(2020, 12, 12)
{:ok, ~D[2020-12-12]}
iex> Date.day_of_week date
6
iex> Date.leap_year? date
true
```

day_of_week/1 calcula em que dia da semana será a data provida. Nesse caso é um sábado. leap_year?/1 verifica se é um ano bissexto. Outras funções podem ser encontradas na documentação.

### NaiveDateTime
Há dois tipos de structs que contém tanto a data e o tempo em apenas um lugar no Elixir. O primeiro dos dois é o NaiveDateTime. A desvantagem é a falta de suporte para fuso horário:

```elixir
iex> NaiveDateTime.utc_now
~N[2022-01-21 19:55:10.008965]
```

Mas ele tem tanto o tempo como a data, então você pode adicionar tempo, por exemplo:

```elixir
iex> NaiveDateTime.add(~N[2018-10-01 00:00:14], 30)
~N[2018-10-01 00:00:44]
```

### DateTime

O segundo, como você pode ter adivinhado a partir do título dessa seção, é DateTime. Não possui as limitações mencionadas no NaiveDateTime: possui data e hora e suporta fusos horários. Mas esteja ciente dos fusos horários. A documentação oficial fala:

 Muitas funções neste módulo requerem um fuso horário do banco de dados. Por padrão, é utilizado o fuso horário do banco de dados que é retornado pela função Calendar.get_time_zone_database/0, cujo padrão é Calendar.UTCOnlyTimeZoneDatabase, que lida apenas com as datas “Etc/UTC” e retorna {:error, :utc_only_time_zone_database} para qualquer outro fuso horário. 

Também, note que você pode criar um instância de DateTime a partir de um NaiveDateTime, apenas fornecendo o fuso horário:

```elixir
iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], "Etc/UTC")
{:ok, #DateTime<2016-05-24 13:26:08.003Z>}
```

### Trabalhando com Timezones

Como observamos na seção anterior, por padrão, o Elixir não possui dados de fuso horário. Para resolver esse problema, precisamos instalar e configurar o pacote tzdata. Após a instalação, você deve configurar globalmente o Elixir para usar o Tzdata com o fuso horário do banco de dados:

```elixir
config :elixir, :time_zone_database, Tzdata.TimeZoneDatabase
```

Agora, vamos tentar criar um horário no fuso horário de Paris e convertê-lo para o horário de Nova York:

```elixir
iex> paris_datetime = DateTime.from_naive!(~N[2019-01-01 12:00:00], "Europe/Paris")
#DateTime<2019-01-01 12:00:00+01:00 CET Europe/Paris>
iex> {:ok, ny_datetime} = DateTime.shift_zone(paris_datetime, "America/New_York")
{:ok, #DateTime<2019-01-01 06:00:00-05:00 EST America/New_York>}
iex> ny_datetime
#DateTime<2019-01-01 06:00:00-05:00 EST America/New_York>
```

Como você pode ver, a hora mudou de 12:00 em Paris para às 6:00 em Nova York, o que é correto - a diferença no fuso horário entre as duas cidades é de 6 horas.

## Processos em Elixir

Para aprender o que é um processo em Elixir, antes você tem que saber o que é uma função.

Por exemplo, IO.puts/1 é uma função que escreve algo na tela. A função se chama puts, ela está no módulo IO (de entrada I e saída O) e ela recebe um argumento:
iex(1)> IO.puts("Adolfo")
Adolfo
:ok
Se tudo dá certo ela retorna o átomo :ok.
Uma função que te permite gerar (tradução talvez imprecisa de spawn, em inglês) é Kernel.spawn/1.

Novamente, o nome dela é spawn, ela faz parte do módulo Kernel e recebe um argumento.
Eu consigo fazer
Kernel.spawn(IO.puts("Adolfo"))
?
Não!

Vamos começar simplificando: toda função que faz parte do módulo Kernel não precisa do nome do módulo antes.
Basta chamar
spawn(IO.puts("Adolfo"))
Vai continuar errado mas com menos letras.
O que Kernel.spawn/1 recebe é uma função de aridade 0, ou seja, que não recebe nenhum argumento.
Como fazemos isso?
Assim:
fn -> 1 end
A função acima não tem nome (anônima) e retorna 1.

Mas veja na imagem que se você dá um spawn nela, nada de interessante acontece:

Image description

Em primeiro lugar, veja que
fn -> 1 end
retornou uma espécie de "código" que identifica a função:
#Function<43.3316493/0 in :erl_eval.expr/6>
E
spawn(fn -> 1 end)
retornou um PID, um Process IDentifier, um identificador de processo:
#PID<0.120.0>
Eu posso atribuir este PID a uma variável:
iex(1)> pid = spawn(fn -> 1 end)
#PID<0.110.0>
E depois perguntar se o processo que foi gerado está vivo:
iex(2)> Process.alive?(pid)
false
Não está pois era uma função muito rápida, que só retornava 1.
Eu posso, por exemplo, fazer o processo "dormir" por 10 segundos antes de retornar o 1.
iex(3)> pid = spawn(fn -> Process.sleep(10000); 1 end)
#PID<0.113.0>
Se rapidamente eu pergunto se o processo, cujo identificador está na variável pid, está vivo, a resposta é sim.
iex(4)> Process.alive?(pid)
true
Mas se pergunto novamente depois de 10 segundos, a resposta será não.
iex(5)> Process.alive?(pid)
false
Se eu fizer isto aqui
iex(6)> pid = spawn(fn -> Process.sleep(10000); IO.puts("Adolfo") end)
#PID<0.117.0>
Adolfo
vai demorar 10 segundos para "Adolfo" ser escrito na tela.

Já se eu fizer isto, será imediato para "Adolfo" aparecer na tela.
iex(7)> pid = spawn(fn -> IO.puts("Adolfo") end)
Adolfo
#PID<0.119.0>
Enfim, isto é somente o básico do básico. 

https://dev.to/elixir_utfpr/o-que-e-um-processo-em-elixir-4j00

- Agentes

Agentes
Os agentes são simples wrappers em torno do estado. Se tudo o que você deseja de um processo é manter o estado, os agentes são uma ótima opção. Vamos iniciar uma iexsessão dentro do projeto com:

$ iex -S mix
E brinque um pouco com os agentes:

iex> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.57.0>}
iex> Agent.update(agent, fn list -> ["eggs" | list] end)
:ok
iex> Agent.get(agent, fn list -> list end)
["eggs"]
iex> Agent.stop(agent)
:ok
Iniciamos um agente com um estado inicial de lista vazia. Atualizamos o estado do agente, adicionando nosso novo item ao topo da lista. O segundo argumento de Agent.update/3é uma função que recebe o estado atual do agente como entrada e retorna o novo estado desejado. Finalmente, recuperamos a lista inteira. O segundo argumento de Agent.get/3é uma função que recebe o estado como entrada e retorna o valor que Agent.get/3ela mesma retornará. Assim que terminarmos com o agente, podemos ligar Agent.stop/3para encerrar o processo do agente.

A Agent.update/3função aceita como segundo argumento qualquer função que receba um argumento e retorne um valor:

iex> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.338.0>}
iex> Agent.update(agent, fn _list -> 123 end)
:ok
iex> Agent.update(agent, fn content -> %{a: content} end)
:ok
iex> Agent.update(agent, fn content -> [12 | [content]] end)
:ok
iex> Agent.update(agent, fn list -> [:nop | list] end)
:ok
iex> Agent.get(agent, fn content -> content end)
[:nop, 12, %{a: 123}]
Como você pode ver, podemos modificar o estado do agente da maneira que quisermos. Portanto, provavelmente não queremos acessar a API do agente em muitos locais diferentes do nosso código. Em vez disso, queremos encapsular todas as funcionalidades relacionadas ao Agente em um único módulo, que chamaremos de KV.Bucket. Antes de implementá-lo, vamos escrever alguns testes que irão delinear a API exposta pelo nosso módulo.

Crie um arquivo em test/kv/bucket_test.exs(lembre-se da .exsextensão) com o seguinte:

defmodule KV.BucketTest do
  use ExUnit.Case, async: true

  test "stores values by key" do
    {:ok, bucket} = KV.Bucket.start_link([])
    assert KV.Bucket.get(bucket, "milk") == nil

    KV.Bucket.put(bucket, "milk", 3)
    assert KV.Bucket.get(bucket, "milk") == 3
  end
end
use ExUnit.Caseé responsável por configurar nosso módulo para testes e importar muitas funcionalidades relacionadas a testes, como a test/2macro.

Nosso primeiro teste começa de novo KV.Bucketchamando the start_link/1e passando uma lista vazia de opções. Em seguida, realizamos algumas get/2operações put/3nele, afirmando o resultado.

Observe também a async: trueopção passada para ExUnit.Case. Esta opção faz com que o caso de teste seja executado em paralelo com outros :asynccasos de teste usando vários núcleos em nossa máquina. Isso é extremamente útil para acelerar nosso conjunto de testes. No entanto, só:async deverá ser definido se o caso de teste não depender ou alterar nenhum valor global. Por exemplo, se o teste exigir gravação no sistema de arquivos ou acesso a um banco de dados, mantenha-o síncrono (omita a opção) para evitar condições de corrida entre testes.:async

Assíncrono ou não, nosso novo teste obviamente deve falhar, já que nenhuma funcionalidade está implementada no módulo que está sendo testado:

** (UndefinedFunctionError) function KV.Bucket.start_link/1 is undefined (module KV.Bucket is not available)
Para corrigir a falha no teste, vamos criar um arquivo lib/kv/bucket.excom o conteúdo abaixo. Sinta-se à vontade para tentar implementar o KV.Bucketmódulo sozinho usando agentes antes de dar uma olhada na implementação abaixo.

defmodule KV.Bucket do
  use Agent

  @doc """
  Starts a new bucket.
  """
  def start_link(_opts) do
    Agent.start_link(fn -> %{} end)
  end

  @doc """
  Gets a value from the `bucket` by `key`.
  """
  def get(bucket, key) do
    Agent.get(bucket, &Map.get(&1, key))
  end

  @doc """
  Puts the `value` for the given `key` in the `bucket`.
  """
  def put(bucket, key, value) do
    Agent.update(bucket, &Map.put(&1, key, value))
  end
end
O primeiro passo em nossa implementação é chamar use Agent. A maior parte das funcionalidades que aprenderemos neste guia, como GenServere Supervisor, segue este padrão. Para todos eles, a chamada usegera uma child_specfunção com configuração padrão, que será útil quando começarmos a supervisionar os processos no capítulo 4.

Em seguida, definimos uma start_link/1função que efetivamente iniciará o agente. É uma convenção definir uma start_link/1função que sempre aceita uma lista de opções. Não planejamos usar nenhuma opção agora, mas poderemos usar mais tarde. Passamos então para call Agent.start_link/1, que recebe uma função anônima que retorna o estado inicial do Agente.

Mantemos um mapa dentro do agente para armazenar nossas chaves e valores. Obter e colocar valores no mapa é feito com a API do Agente e o operador de captura &, apresentados no Guia de primeiros passos . O agente passa seu estado para a função anônima por meio do &1argumento quando Agent.get/2e Agent.update/2são chamados.

Agora que o KV.Bucketmódulo foi definido, nosso teste deve passar! Você pode tentar você mesmo executando: mix test.

Configuração de teste com retornos de chamada ExUnit
Antes de prosseguir e adicionar mais recursos ao KV.Bucket, vamos falar sobre retornos de chamada ExUnit. Como você pode esperar, todos KV.Bucketos testes exigirão que um agente de bucket esteja instalado e funcionando. Felizmente, o ExUnit oferece suporte a retornos de chamada que nos permitem pular essas tarefas repetitivas.

Vamos reescrever o caso de teste para usar retornos de chamada:

defmodule KV.BucketTest do
  use ExUnit.Case, async: true

  setup do
    {:ok, bucket} = KV.Bucket.start_link([])
    %{bucket: bucket}
  end

  test "stores values by key", %{bucket: bucket} do
    assert KV.Bucket.get(bucket, "milk") == nil

    KV.Bucket.put(bucket, "milk", 3)
    assert KV.Bucket.get(bucket, "milk") == 3
  end
end
Primeiro definimos um retorno de chamada de configuração com a ajuda da setup/1macro. A setup/1macro define um retorno de chamada que é executado antes de cada teste, no mesmo processo do próprio teste.

Observe que precisamos de um mecanismo para passar o bucketpid do retorno de chamada para o teste. Fazemos isso usando o contexto de teste . Quando retornarmos %{bucket: bucket}do retorno de chamada, o ExUnit mesclará esse mapa no contexto de teste. Como o contexto de teste é um mapa em si, podemos combinar padrões com o bucket fora dele, fornecendo acesso ao bucket dentro do teste:

test "stores values by key", %{bucket: bucket} do
  # `bucket` is now the bucket from the setup block
end
Você pode ler mais sobre casos ExUnit na ExUnit.Casedocumentação do módulo e mais sobre retornos de chamada em ExUnit.Callbacksdocs .

Outras ações do agente
Além de obter um valor e atualizar o estado do agente, os agentes nos permitem obter um valor e atualizar o estado do agente em uma chamada de função via Agent.get_and_update/2. Vamos implementar uma KV.Bucket.delete/2função que exclui uma chave do bucket, retornando seu valor atual:

@doc """
Deletes `key` from `bucket`.

Returns the current value of `key`, if `key` exists.
"""
def delete(bucket, key) do
  Agent.get_and_update(bucket, &Map.pop(&1, key))
end
Agora é sua vez de escrever um teste para a funcionalidade acima! Além disso, certifique-se de explorar a documentação do Agentmódulo para aprender mais sobre eles.

Cliente/Servidor em agentes
Antes de passarmos para o próximo capítulo, vamos discutir a dicotomia cliente/servidor nos agentes. Vamos expandir a delete/2função que acabamos de implementar:

def delete(bucket, key) do
  Agent.get_and_update(bucket, fn dict ->
    Map.pop(dict, key)
  end)
end
Tudo o que está dentro da função que passamos para o agente acontece no processo do agente. Neste caso, como o processo agente é aquele que recebe e responde às nossas mensagens, dizemos que o processo agente é o servidor. Tudo fora da função está acontecendo no cliente.

Esta distinção é importante. Se houver ações caras a serem realizadas, você deve considerar se será melhor realizar essas ações no cliente ou no servidor. Por exemplo:

def delete(bucket, key) do
  Process.sleep(1000) # puts client to sleep
  Agent.get_and_update(bucket, fn dict ->
    Process.sleep(1000) # puts server to sleep
    Map.pop(dict, key)
  end)
end
Quando uma ação longa é executada no servidor, todas as outras solicitações para esse servidor específico aguardarão até que a ação seja concluída, o que pode causar o tempo limite de alguns clientes.

https://elixir-lang.org/getting-started/mix-otp/agent.html

