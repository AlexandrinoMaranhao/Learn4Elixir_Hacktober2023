# Learn4Elixir - Capítulo 4

## Data e Tempo

Neste Capitulo você irá aprender um pouco sobre: Data e Hora, Processos em Elixir e Agentes.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter4.livemd)

No Elixir, você pode usar o módulo DateTime para trabalhar com datas e horas. O Elixir possui uma biblioteca robusta para manipulação de datas e horas, que permite realizar diversas operações, como formatação, cálculos e comparações. Aqui estão alguns exemplos de como usar datas e horas.

## Obter a Data e a Hora Atuais

Você pode obter a data e hora atuais usando a função DateTime.now/2 (o segundo argumento não é obrigatório). Por exemplo:

```elixir
{:ok, data_hora} = DateTime.now("Etc/UTC")
" #{data_hora}: Data e hora agora no horário do Tempo Universal Coordenado (UTC)."
```

Observe que o resultado da expressão acima vai mudar a cada vez que você avaliar a célula.

## Obter Partes de uma Data e Hora

Você pode acessar partes específicas de uma data e hora, como o ano, mês, dia, hora, minuto e segundo, usando os campos 'year', 'month', 'day', etc.

```elixir
{:ok, data_hora} = DateTime.now("Etc/UTC")
"Ano: #{data_hora.year}, Mês: #{data_hora.month}, Dia: #{data_hora.day}"
```

Veja mais opções em [Date](https://hexdocs.pm/elixir/Date.html).

## Manipular Datas e Horas

Você pode realizar operações de manipulação de datas e horas, como adicionar ou subtrair dias, horas, minutos, etc., usando as funções disponíveis no módulo DateTime. Por exemplo, para adicionar 3 dias a partir da data atual:

```elixir
{:ok, current_datetime} = DateTime.now("Etc/UTC")
future_datetime = DateTime.add(current_datetime, 3, :day)
"Data daqui a 3 dias: #{future_datetime}"
```

## Comparar Datas e Horas

Você pode comparar datas e horas com '>', '<', '==' e outros operadores de comparação.

```elixir
{:ok, current_datetime} = DateTime.now("Etc/UTC")
future_datetime = DateTime.add(current_datetime, 3, :day)

if future_datetime > current_datetime do
  "A data futura é posterior à data atual."
else
  "A data futura não é posterior à data atual."
end
```

## Processos em Elixir

Os processos são a principal unidade de concorrência em Elixir e permitem que você execute tarefas em paralelo, compartilhe dados e crie sistemas concorrentes. Aqui estão alguns exemplos de como usar processos.

## Criar um Processo

Para criar um processo em Elixir, você pode usar a função spawn/1 ou Task.start/1. Aqui está um exemplo usando Task.start/1 para criar um processo que imprime "Hello, World!" após um atraso de 2 segundos:

```elixir
task =
  Task.start(fn ->
    :timer.sleep(2000)
    IO.puts("Hello, World!")
  end)
```

## Aguardar o Término do Processo

Você pode usar Task.await/2 para aguardar o término de um processo criado com Task.start/1:

```elixir
Task.await(task)
```

Isso fará com que o processo principal espere até que o processo da tarefa seja concluído.

## Enviar e Receber Mensagens entre Processos

Os processos em Elixir podem se comunicar entre si por meio do envio e recebimento de mensagens. Você pode usar a função send/2 para enviar mensagens e receive/1 para receber mensagens. Aqui está um exemplo de envio e recebimento de mensagens entre dois processos:

```elixir
pid =
  spawn(fn ->
    send(self(), {:message, "Hello from another process!"})
  end)

receive do
  {:message, message} ->
    IO.puts("Mensagem Recebida: #{message}")
end
```

## Encerrar um Processo

Você pode encerrar um processo usando a função Process.exit/2 ou deixando que ele termine naturalmente. Por exemplo, para encerrar um processo com uma mensagem de saída:

```elixir
Process.exit(pid, :shutdown)
```

## Agentes

Agentes são uma maneira de compartilhar e gerenciar estado em ambientes concorrentes de forma segura. Aqui está um exemplo de como usar agentes.

## Inicialize um Agente (Servidor)

Comece inicializando um agente que conterá o estado que você deseja compartilhar. Você pode fazer isso em uma célula do Livebook:

```elixir
# Inicialize um agente com um estado inicial
{:ok, agent} = Agent.start(fn -> 0 end)
```

Neste exemplo, o agente é inicializado com um estado inicial de 0.

## Lendo e atualizando o estado

Em seguida, você pode ler ou atualizar seu estado.

## Ler o estado do agente

```elixir
Agent.get(agent, fn state -> state end)
```

## Atualizar o estado do agente

```elixir
Agent.update(agent, fn _state -> new_state end)
```

## Interaja com o Agente

Agora você pode usar as funções do cliente para interagir com o agente em células subsequentes do Livebook:

```elixir
# Use o cliente para ler o estado atual do agente
current_state = get_state(agent)
IO.puts("Estado Atual: #{current_state}")

# Atualize o estado do agente usando o cliente
new_state = current_state + 1
update_state(agent, new_state)
IO.puts("Estado Atualizado: #{new_state}")
```

## Encerre o Agente (Opcional)

Após concluir a interação com o agente, você pode encerrá-lo para liberar os recursos associados. Você pode fazer isso em uma célula separada:

```elixir
# Encerre o agente
:ok = Agent.stop(agent)
```

## Exercícios
