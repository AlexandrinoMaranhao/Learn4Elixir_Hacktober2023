# Learn4Elixir - Capítulo 4

Neste Capitulo você irá aprender sobre: Data e Tempo, Processos em Elixir e Agentes.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter4.livemd)

# Data e Tempo 

O Elixir tem alguns módulos que trabalham com tempo. Ainda que precise ser notado que essa funcionalidade é limitada para trabalhar com fuso horário UTC.

Vamos começar pegando o tempo atual:

```elixir
iex> Time.utc_now
~T[19:39:31.056226]
```

Note que nós vamos ter um sigil que pode ser usado para criar uma struct Time também:

```elixir
iex> ~T[19:39:31.056226]
~T[19:39:31.056226]
```

Você pode aprender mais sobre sigil na lição sobre sigils. É fácil acessar partes desta struct:

```elixir
iex> t = ~T[19:39:31.056226]
~T[19:39:31.056226]
iex> t.hour
19
iex> t.minute
39
iex> t.day
** (KeyError) key :day not found in: ~T[19:39:31.056226]
```

Mas há uma pegadinha: como você pode ter notado, essa struct contém apenas tempo de um dia, dados de dia/mês/ano não estão presentes.

## Date

Ao contrário do Time, a struct Date tem as informações sobre a data sem nenhuma informação sobre o tempo.

```elixir
iex> Date.utc_today
~D[2028-10-21]
```

Mas ele tem algumas funções úteis para trabalhar com datas:

```elixir
iex> {:ok, date} = Date.new(2020, 12, 12)
{:ok, ~D[2020-12-12]}
iex> Date.day_of_week date
6
iex> Date.leap_year? date
true
```

day_of_week/1 calcula em que dia da semana será a data provida. Nesse caso é um sábado. leap_year?/1 verifica se é um ano bissexto. Outras funções podem ser encontradas na documentação.

## NaiveDateTime

Há dois tipos de structs que contém tanto a data e o tempo em apenas um lugar no Elixir. O primeiro dos dois é o NaiveDateTime. A desvantagem é a falta de suporte para fuso horário:

```elixir
iex> NaiveDateTime.utc_now
~N[2022-01-21 19:55:10.008965]
```

Mas ele tem tanto o tempo como a data, então você pode adicionar tempo, por exemplo:

```elixir
iex> NaiveDateTime.add(~N[2018-10-01 00:00:14], 30)
~N[2018-10-01 00:00:44]
```

## DateTime

O segundo, como você pode ter adivinhado a partir do título dessa seção, é DateTime. Não possui as limitações mencionadas no NaiveDateTime: possui data e hora e suporta fusos horários. Mas esteja ciente dos fusos horários. A documentação oficial fala:

 Muitas funções neste módulo requerem um fuso horário do banco de dados. Por padrão, é utilizado o fuso horário do banco de dados que é retornado pela função Calendar.get_time_zone_database/0, cujo padrão é Calendar.UTCOnlyTimeZoneDatabase, que lida apenas com as datas “Etc/UTC” e retorna {:error, :utc_only_time_zone_database} para qualquer outro fuso horário. 

Também, note que você pode criar um instância de DateTime a partir de um NaiveDateTime, apenas fornecendo o fuso horário:

```elixir
iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], "Etc/UTC")
{:ok, #DateTime<2016-05-24 13:26:08.003Z>}
```

## Trabalhando com Timezones

Como observamos na seção anterior, por padrão, o Elixir não possui dados de fuso horário. Para resolver esse problema, precisamos instalar e configurar o pacote tzdata. Após a instalação, você deve configurar globalmente o Elixir para usar o Tzdata com o fuso horário do banco de dados:

```elixir
config :elixir, :time_zone_database, Tzdata.TimeZoneDatabase
```

Agora, vamos tentar criar um horário no fuso horário de Paris e convertê-lo para o horário de Nova York:

```elixir
iex> paris_datetime = DateTime.from_naive!(~N[2019-01-01 12:00:00], "Europe/Paris")
#DateTime<2019-01-01 12:00:00+01:00 CET Europe/Paris>
iex> {:ok, ny_datetime} = DateTime.shift_zone(paris_datetime, "America/New_York")
{:ok, #DateTime<2019-01-01 06:00:00-05:00 EST America/New_York>}
iex> ny_datetime
#DateTime<2019-01-01 06:00:00-05:00 EST America/New_York>
```

Como você pode ver, a hora mudou de 12:00 em Paris para às 6:00 em Nova York, o que é correto - a diferença no fuso horário entre as duas cidades é de 6 horas.

# Processos em Elixir

USAR ALGUNS DOS EXEMPLOS EM https://dev.to/elixir_utfpr/o-que-e-um-processo-em-elixir-4j00

Em Elixir, um processo é uma unidade de execução leve e concorrente. É uma das características mais fundamentais da linguagem e é usado para criar sistemas concorrentes e paralelos de maneira eficiente.

Aqui estão algumas características importantes dos processos em Elixir:

## Leveza

Os processos em Elixir são leves em comparação com as threads tradicionais do sistema operacional. Isso significa que você pode criar milhares ou até milhões de processos em uma única máquina sem esgotar recursos significativos.

## Isolamento

Cada processo em Elixir é isolado dos outros. Eles têm sua própria pilha de execução e não compartilham memória diretamente. Isso torna mais seguro lidar com a concorrência, pois os processos não podem corromper uns aos outros.

## Comunicação

Os processos em Elixir podem se comunicar entre si usando mensagens. Essas mensagens são enviadas e recebidas por meio de canais de comunicação chamados "mailboxes". Isso permite a comunicação assíncrona entre os processos.

## Supervisão

Elixir possui um mecanismo de supervisão embutido, que permite monitorar e gerenciar processos. Se um processo falhar, ele pode ser reiniciado automaticamente, garantindo maior resiliência e disponibilidade no sistema.

## Escalabilidade

Devido à sua natureza leve, os processos em Elixir são altamente escaláveis. Você pode criar vários processos para lidar com tarefas paralelas e, se necessário, espalhar esses processos em várias máquinas para criar sistemas distribuídos.

## Concorrência Explícita

Elixir facilita a programação concorrente explícita. Você pode iniciar processos facilmente usando a função spawn/1 e coordenar a execução de tarefas paralelas.

Aqui está um exemplo simples de como criar e comunicar com processos em Elixir:

```elixir
# Criar um processo que imprime uma mensagem
iex> pid = spawn(fn ->
...>  IO.puts("Processo filho executando")
...> end)

# Enviar uma mensagem para o processo
iex> send(pid, "Olá, processo filho!")

# Receber a mensagem no processo filho
iex> receive do
...>  message -> IO.puts("Processo filho recebeu a mensagem: #{message}")
...> end
```

# Agentes

Os agentes são simples wrappers em torno do estado. Se tudo o que você deseja de um processo é manter o estado, os agentes são uma ótima opção. Vamos iniciar uma iexsessão dentro do projeto com:

```elixir
$ iex -S mix
```

E brinque um pouco com os agentes:

```elixir
iex> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.57.0>}
iex> Agent.update(agent, fn list -> ["eggs" | list] end)
:ok
iex> Agent.get(agent, fn list -> list end)
["eggs"]
iex> Agent.stop(agent)
:ok
```

Iniciamos um agente com um estado inicial de lista vazia. Atualizamos o estado do agente, adicionando nosso novo item ao topo da lista. O segundo argumento de Agent.update/3é uma função que recebe o estado atual do agente como entrada e retorna o novo estado desejado. Finalmente, recuperamos a lista inteira. O segundo argumento de Agent.get/3é uma função que recebe o estado como entrada e retorna o valor que Agent.get/3ela mesma retornará. Assim que terminarmos com o agente, podemos ligar Agent.stop/3para encerrar o processo do agente.

A Agent.update/3função aceita como segundo argumento qualquer função que receba um argumento e retorne um valor:

```elixir
iex> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.338.0>}
iex> Agent.update(agent, fn _list -> 123 end)
:ok
iex> Agent.update(agent, fn content -> %{a: content} end)
:ok
iex> Agent.update(agent, fn content -> [12 | [content]] end)
:ok
iex> Agent.update(agent, fn list -> [:nop | list] end)
:ok
iex> Agent.get(agent, fn content -> content end)
[:nop, 12, %{a: 123}]
```

Como você pode ver, podemos modificar o estado do agente da maneira que quisermos. Portanto, provavelmente não queremos acessar a API do agente em muitos locais diferentes do nosso código. Em vez disso, queremos encapsular todas as funcionalidades relacionadas ao Agente em um único módulo, que chamaremos de KV.Bucket. Antes de implementá-lo, vamos escrever alguns testes que irão delinear a API exposta pelo nosso módulo.

Crie um arquivo em test/kv/bucket_test.exs(lembre-se da .exsextensão) com o seguinte:

```elixir
iex> defmodule KV.BucketTest do
...>  use ExUnit.Case, async: true

...>  test "stores values by key" do
...>    {:ok, bucket} = KV.Bucket.start_link([])
...>    assert KV.Bucket.get(bucket, "milk") == nil

...>    KV.Bucket.put(bucket, "milk", 3)
...>    assert KV.Bucket.get(bucket, "milk") == 3
...>  end
...> end
```

use ExUnit.Caseé responsável por configurar nosso módulo para testes e importar muitas funcionalidades relacionadas a testes, como a test/2macro.

Nosso primeiro teste começa de novo KV.Bucketchamando the start_link/1e passando uma lista vazia de opções. Em seguida, realizamos algumas get/2operações put/3nele, afirmando o resultado.

Observe também a async: trueopção passada para ExUnit.Case. Esta opção faz com que o caso de teste seja executado em paralelo com outros :asynccasos de teste usando vários núcleos em nossa máquina. Isso é extremamente útil para acelerar nosso conjunto de testes. No entanto, só:async deverá ser definido se o caso de teste não depender ou alterar nenhum valor global. Por exemplo, se o teste exigir gravação no sistema de arquivos ou acesso a um banco de dados, mantenha-o síncrono (omita a opção) para evitar condições de corrida entre testes.:async

Assíncrono ou não, nosso novo teste obviamente deve falhar, já que nenhuma funcionalidade está implementada no módulo que está sendo testado:

```elixir
** (UndefinedFunctionError) function KV.Bucket.start_link/1 is undefined (module KV.Bucket is not available)
```

Para corrigir a falha no teste, vamos criar um arquivo lib/kv/bucket.excom o conteúdo abaixo. Sinta-se à vontade para tentar implementar o KV.Bucketmódulo sozinho usando agentes antes de dar uma olhada na implementação abaixo.

```elixir
iex> defmodule KV.Bucket do
...>  use Agent

  @doc """
  Starts a new bucket.
  """
iex>  def start_link(_opts) do
...>    Agent.start_link(fn -> %{} end)
...>  end

  @doc """
  Gets a value from the `bucket` by `key`.
  """
iex>  def get(bucket, key) do
...>    Agent.get(bucket, &Map.get(&1, key))
...>  end

  @doc """
  Puts the `value` for the given `key` in the `bucket`.
  """
iex>  def put(bucket, key, value) do
...>    Agent.update(bucket, &Map.put(&1, key, value))
...>  end
...> end
```

O primeiro passo em nossa implementação é chamar use Agent. A maior parte das funcionalidades que aprenderemos neste guia, como GenServere Supervisor, segue este padrão. Para todos eles, a chamada usegera uma child_specfunção com configuração padrão, que será útil quando começarmos a supervisionar os processos no capítulo 4.

Em seguida, definimos uma start_link/1função que efetivamente iniciará o agente. É uma convenção definir uma start_link/1função que sempre aceita uma lista de opções. Não planejamos usar nenhuma opção agora, mas poderemos usar mais tarde. Passamos então para call Agent.start_link/1, que recebe uma função anônima que retorna o estado inicial do Agente.

Mantemos um mapa dentro do agente para armazenar nossas chaves e valores. Obter e colocar valores no mapa é feito com a API do Agente e o operador de captura &, apresentados no Guia de primeiros passos . O agente passa seu estado para a função anônima por meio do &1argumento quando Agent.get/2e Agent.update/2são chamados.

Agora que o KV.Bucketmódulo foi definido, nosso teste deve passar! Você pode tentar você mesmo executando: mix test.

Configuração de teste com retornos de chamada ExUnit
Antes de prosseguir e adicionar mais recursos ao KV.Bucket, vamos falar sobre retornos de chamada ExUnit. Como você pode esperar, todos KV.Bucketos testes exigirão que um agente de bucket esteja instalado e funcionando. Felizmente, o ExUnit oferece suporte a retornos de chamada que nos permitem pular essas tarefas repetitivas.

Vamos reescrever o caso de teste para usar retornos de chamada:

```elixir
iex> defmodule KV.BucketTest do
...>  use ExUnit.Case, async: true

...>  setup do
...>    {:ok, bucket} = KV.Bucket.start_link([])
...>    %{bucket: bucket}
...>  end

iex>  test "stores values by key", %{bucket: bucket} do
...>    assert KV.Bucket.get(bucket, "milk") == nil

...>    KV.Bucket.put(bucket, "milk", 3)
...>    assert KV.Bucket.get(bucket, "milk") == 3
...>  end
...> end
```

Primeiro definimos um retorno de chamada de configuração com a ajuda da setup/1macro. A setup/1macro define um retorno de chamada que é executado antes de cada teste, no mesmo processo do próprio teste.

Observe que precisamos de um mecanismo para passar o bucketpid do retorno de chamada para o teste. Fazemos isso usando o contexto de teste . Quando retornarmos %{bucket: bucket}do retorno de chamada, o ExUnit mesclará esse mapa no contexto de teste. Como o contexto de teste é um mapa em si, podemos combinar padrões com o bucket fora dele, fornecendo acesso ao bucket dentro do teste:

```elixir
iex> test "stores values by key", %{bucket: bucket} do
  # `bucket` is now the bucket from the setup block
...> end
```

Você pode ler mais sobre casos ExUnit na ExUnit.Casedocumentação do módulo e mais sobre retornos de chamada em ExUnit.Callbacksdocs .

## Outras Ações do Agente

Além de obter um valor e atualizar o estado do agente, os agentes nos permitem obter um valor e atualizar o estado do agente em uma chamada de função via Agent.get_and_update/2. Vamos implementar uma KV.Bucket.delete/2função que exclui uma chave do bucket, retornando seu valor atual:

```elixir
@doc """
iex> Deletes `key` from `bucket`.

Returns the current value of `key`, if `key` exists.
"""
iex> def delete(bucket, key) do
...>   Agent.get_and_update(bucket, &Map.pop(&1, key))
...> end
```

## Cliente/Servidor em Agentes

No Livebook, você pode criar um servidor e um cliente para interagir com agentes da mesma maneira que faria em um ambiente Elixir tradicional. Agentes permitem que você compartilhe estado entre diferentes partes do código de forma segura em um ambiente concorrente. Aqui está um exemplo de como usar um cliente e um servidor em agentes no Livebook:

### Servidor (Agente):

Vamos começar definindo o servidor (agente) que mantém um contador como estado interno. Você pode definir isso em uma célula:

```elixir
# Inicie o agente com um contador inicial de 0
{:ok, agent} = Agent.start(fn -> 0 end)
```

### Cliente:

Em seguida, você pode criar um cliente que interage com o servidor (agente) para ler e atualizar o contador. Você pode fazer isso em uma célula separada:

```elixir
# Função para ler o contador do agente
defp get_count(agent) do
  Agent.get(agent, fn count -> count end)
end

# Função para atualizar o contador do agente
defp increment_count(agent) do
  Agent.update(agent, fn count -> count + 1 end)
end
```

### Uso do Cliente e Servidor:

Agora que você tem um cliente e um servidor, pode usá-los para interagir com o agente em células subsequentes:

```elixir
# Use o cliente para ler e atualizar o contador
IO.puts("Contador Inicial: #{get_count(agent)}")
increment_count(agent)
IO.puts("Contador Atualizado: #{get_count(agent)}")
```

### Encerrando o Agente:

Depois de concluir a interação com o agente, é importante encerrá-lo para liberar os recursos. Você pode fazer isso em outra célula:

```elixir
# Encerre o agente
:ok = Agent.stop(agent)
```

Lembre-se de que você pode executar essas células em ordem no Livebook para ver como o cliente e o servidor interagem com o agente. O servidor (agente) mantém o estado interno (nesse caso, um contador), e o cliente lê e atualiza esse estado. Isso permite a comunicação segura entre diferentes partes do código em um ambiente concorrente. Certifique-se de que suas células estejam configuradas para serem executáveis para ver os resultados da interação.

## Exercício


