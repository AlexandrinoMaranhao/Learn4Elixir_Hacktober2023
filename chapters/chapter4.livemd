# Learn4Elixir - Capítulo 4

# Data e Tempo 

Neste Capitulo você irá aprender sobre: Data e Tempo, Processos em Elixir e Agentes.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter4.livemd)

No Livebook, você pode usar o módulo DateTime para trabalhar com datas e tempos. O Elixir possui uma biblioteca robusta para manipulação de datas e tempos, que permite realizar diversas operações, como formatação, cálculos e comparações. Aqui estão alguns exemplos de como usar datas e tempos no Livebook:

## Obter a Data e a Hora Atuais:

Você pode obter a data e hora atuais usando a função DateTime.now/0. Por exemplo:

```elixir
current_datetime = DateTime.now()
IO.puts("Data e Hora Atuais: #{current_datetime}")
```

## Obter Partes de uma Data e Hora:

Você pode acessar partes específicas de uma data e hora, como o ano, mês, dia, hora, minuto e segundo, usando funções como DateTime.year/1, DateTime.month/1, etc. Por exemplo:

```elixir
current_datetime = DateTime.now()
year = DateTime.year(current_datetime)
month = DateTime.month(current_datetime)
day = DateTime.day(current_datetime)
IO.puts("Ano: #{year}, Mês: #{month}, Dia: #{day}")
```

## Manipular Datas e Tempos:

Você pode realizar operações de manipulação de datas e tempos, como adicionar ou subtrair dias, horas, minutos, etc., usando as funções disponíveis no módulo DateTime. Por exemplo, para adicionar 3 dias a partir da data atual:

```elixir
current_datetime = DateTime.now()
future_datetime = DateTime.add(current_datetime, 3, :days)
IO.puts("Data daqui a 3 dias: #{future_datetime}")
```

## Formatar Datas e Tempos:

Você pode formatar datas e tempos em uma representação legível usando a função DateTime.format/2. Por exemplo:

```elixir
current_datetime = DateTime.now()
formatted_datetime = DateTime.format(current_datetime, "{D}/{M}/{Y} {h}:{m}:{s}")
IO.puts("Data e Hora Formatadas: #{formatted_datetime}")
```

## Comparar Datas e Tempos:

Você pode comparar datas e tempos usando operadores de comparação padrão, como <, <=, >, >=, ==, e /=. Por exemplo:

```elixir
current_datetime = DateTime.now()
future_datetime = DateTime.add(current_datetime, 3, :days)
if future_datetime > current_datetime do
  IO.puts("A data futura é posterior à data atual.")
end
```

## Date

No Elixir, não existe um tipo nativo chamado "Date" como em algumas outras linguagens de programação. No entanto, você pode usar o módulo Date do pacote Calendar para trabalhar com datas em Elixir. O pacote Calendar é uma biblioteca externa que oferece funcionalidades avançadas para manipulação de datas. Para usá-lo no Livebook, você precisa primeiro adicionar o pacote às dependências do projeto. Abaixo estão as etapas para fazer isso e começar a usar o Date:

### Adicionar o Pacote Calendar às Dependências:

Você pode adicionar o pacote calendar ao seu projeto Elixir editando o arquivo mix.exs do seu Livebook e adicionando :calendar à lista de dependências:

```elixir
defp deps do
  [
    {:livebook, "~> 0.5.0"},
    {:calendar, "~> 0.19.6"}  # Adicione esta linha
  ]
end
```

Após adicionar a dependência, você precisa executar o comando mix deps.get para buscar e instalar o pacote calendar.

### Usar o Módulo Date do Pacote Calendar:

Agora que você adicionou o pacote calendar, pode usar o módulo Date para trabalhar com datas. Aqui estão alguns exemplos de como usar o Date no Livebook:

```elixir
# Importe o módulo Date para usar as funções
import Calendar.Date

# Criar uma data
date = Date.new(2023, 9, 30)
IO.puts("Data: #{inspect(date)}")

# Obter o dia, mês e ano
day = Date.day(date)
month = Date.month(date)
year = Date.year(date)
IO.puts("Dia: #{day}, Mês: #{month}, Ano: #{year}")

# Formatando a data
formatted_date = Date.format(date, "{YYYY}-{0M}-{0D}")
IO.puts("Data Formatada: #{formatted_date}")

# Adicionando e subtraindo dias
future_date = Date.add(date, 3)
past_date = Date.subtract(date, 5)
IO.puts("Data Futura: #{inspect(future_date)}")
IO.puts("Data Passada: #{inspect(past_date)}")
```

## NaiveDateTime

NaiveDateTime é um tipo de data e hora no Elixir que não está associado a um fuso horário específico. Ao contrário do DateTime (com informações de fuso horário), o NaiveDateTime não lida com compensações de fuso horário e outras informações relacionadas a fusos horários.

Para usar NaiveDateTime no Livebook, você pode seguir estas etapas:

### Importe o Módulo NaiveDateTime:

Primeiro, importe o módulo NaiveDateTime do pacote Calendar no seu Livebook. Adicione o :calendar como dependência em seu arquivo mix.exs e execute mix deps.get para garantir que o pacote esteja instalado.

```elixir
# Importe o módulo NaiveDateTime
import Calendar.NaiveDateTime
```

### Crie e Manipule NaiveDateTimes:

Agora você pode criar e manipular objetos NaiveDateTime no seu Livebook. Aqui estão alguns exemplos:

```elixir
# Criar um NaiveDateTime
naive_datetime = NaiveDateTime.new({2023, 9, 30, 12, 0, 0})
IO.puts("NaiveDateTime: #{inspect(naive_datetime)}")

# Obter partes da data e hora
year = NaiveDateTime.year(naive_datetime)
month = NaiveDateTime.month(naive_datetime)
day = NaiveDateTime.day(naive_datetime)
hour = NaiveDateTime.hour(naive_datetime)
minute = NaiveDateTime.minute(naive_datetime)
second = NaiveDateTime.second(naive_datetime)

IO.puts("Ano: #{year}, Mês: #{month}, Dia: #{day}")
IO.puts("Hora: #{hour}, Minuto: #{minute}, Segundo: #{second}")

# Formatando o NaiveDateTime
formatted_datetime = NaiveDateTime.format(naive_datetime, "{YYYY}-{0M}-{0D} {0h}:{0m}:{0s}")
IO.puts("NaiveDateTime Formatado: #{formatted_datetime}")

# Adicionar e subtrair horas, minutos e segundos
future_datetime = NaiveDateTime.add(naive_datetime, hours: 3, minutes: 30)
past_datetime = NaiveDateTime.subtract(naive_datetime, seconds: 60)
IO.puts("NaiveDateTime Futuro: #{inspect(future_datetime)}")
IO.puts("NaiveDateTime Passado: #{inspect(past_datetime)}")
```

## Trabalhando com Timezones

Para trabalhar com fusos horários no Livebook, você pode usar a biblioteca tzdata para obter informações sobre fusos horários e timex para realizar cálculos e formatações de datas e horas levando em consideração fusos horários. O tzdata fornece informações sobre fusos horários, enquanto o timex oferece recursos avançados de manipulação de datas e horas, incluindo a capacidade de considerar fusos horários.

Aqui estão os passos para usar fusos horários no Livebook:

### Adicione as Dependências:

Certifique-se de que as dependências tzdata e timex estão listadas em seu arquivo mix.exs:

```elixir
defp deps do
  [
    {:livebook, "~> 0.5.0"},
    {:tzdata, "~> 1.1"},
    {:timex, "~> 3.7"}
  ]
end
```

Execute mix deps.get para buscar e instalar essas dependências.

### Importe os Módulos Necessários:

No Livebook, importe os módulos Tzdata e Timex para usar suas funções:

```elixir
import Tzdata
import Timex
```

### Trabalhando com Fusos Horários:

Você pode usar o tzdata para obter informações sobre fusos horários. Por exemplo, para obter a lista de fusos horários disponíveis:

```elixir
timezones = Tzdata.all_timezones()
IO.puts("Fusos Horários Disponíveis: #{inspect(timezones)}")
```

Para obter o fuso horário atual de um local específico:

```
elixir
timezone = Tzdata.get_timezone("America/New_York")
IO.puts("Fuso Horário de Nova York: #{inspect(timezone)}")
```

### Manipulando Datas e Horas com Fusos Horários:

Você pode usar o timex para criar objetos de data e hora com fusos horários e realizar cálculos com eles. Por exemplo:

```elixir
# Criar uma data e hora com fuso horário específico
datetime = Timex.now() |> Timex.shift_zone("America/New_York")
IO.puts("Data e Hora em Nova York: #{inspect(datetime)}")

# Converter uma data e hora para outro fuso horário
new_datetime = Timex.shift_zone(datetime, "Europe/London")
IO.puts("Data e Hora em Londres: #{inspect(new_datetime)}")
```

Além disso, o timex oferece funções para formatação, análise, adição e subtração de datas e horas com fusos horários.

# Processos em Elixir

No Livebook, você pode usar processos em Elixir da mesma forma que faria em um ambiente Elixir tradicional. Os processos são a principal unidade de concorrência em Elixir e permitem que você execute tarefas em paralelo, compartilhe dados e crie sistemas concorrentes. Aqui estão alguns exemplos de como usar processos no Livebook:

## Criar um Processo:

Para criar um processo em Elixir, você pode usar a função spawn/1 ou Task.start/1. Aqui está um exemplo usando Task.start/1 para criar um processo que imprime "Hello, World!" após um atraso de 2 segundos:

```elixir
task = Task.start(fn ->
  :timer.sleep(2000)
  IO.puts("Hello, World!")
end)
```

## Aguardar o Término do Processo:

Você pode usar Task.await/2 para aguardar o término de um processo criado com Task.start/1:

```elixir
Task.await(task)
```

Isso fará com que o processo principal espere até que o processo da tarefa seja concluído.

## Enviar e Receber Mensagens entre Processos:

Os processos em Elixir podem se comunicar entre si por meio do envio e recebimento de mensagens. Você pode usar a função send/2 para enviar mensagens e receive/1 para receber mensagens. Aqui está um exemplo de envio e recebimento de mensagens entre dois processos:

```elixir
pid = spawn(fn ->
  send(self(), {:message, "Hello from another process!"})
end)

receive do
  {:message, message} ->
    IO.puts("Mensagem Recebida: #{message}")
end
```

## Encerrar um Processo:

Você pode encerrar um processo usando a função Process.exit/2 ou deixando que ele termine naturalmente. Por exemplo, para encerrar um processo com uma mensagem de saída:

```elixir
Process.exit(pid, :shutdown)
```

## Supervisionar Processos (opcional):

Em sistemas mais complexos, você pode usar o mecanismo de supervisão do Elixir para monitorar e gerenciar processos automaticamente. Isso ajuda a criar sistemas resilientes que podem se recuperar de falhas.

Para criar um supervisor e gerenciar processos, você pode usar o módulo Supervisor. No entanto, a criação de supervisores requer um ambiente mais complexo e pode não ser adequada para exemplos simples no Livebook.

# Agentes

Para usar agentes no Livebook, você pode seguir os mesmos princípios que aplicaria em um ambiente Elixir tradicional. Agentes são uma maneira de compartilhar e gerenciar estado em ambientes concorrentes de forma segura. Aqui está um exemplo de como usar agentes no Livebook:

### Inicialize um Agente (Servidor):

Comece inicializando um agente que conterá o estado que você deseja compartilhar. Você pode fazer isso em uma célula do Livebook:

```elixir
# Inicialize um agente com um estado inicial
{:ok, agent} = Agent.start(fn -> 0 end)
```

Neste exemplo, o agente é inicializado com um estado inicial de 0.

### Crie Funções de Cliente:

Em seguida, você pode criar funções de cliente que interagem com o agente para ler ou atualizar seu estado. Você pode definir essas funções em células separadas:

```elixir
# Função para ler o estado do agente
defp get_state(agent) do
  Agent.get(agent, fn state -> state end)
end

# Função para atualizar o estado do agente

defp update_state(agent, new_state) do
  Agent.update(agent, fn _state -> new_state end)
end
```

### Interaja com o Agente:

Agora você pode usar as funções do cliente para interagir com o agente em células subsequentes do Livebook:

```elixir
# Use o cliente para ler o estado atual do agente
current_state = get_state(agent)
IO.puts("Estado Atual: #{current_state}")

# Atualize o estado do agente usando o cliente
new_state = current_state + 1
update_state(agent, new_state)
IO.puts("Estado Atualizado: #{new_state}")
```

### Encerre o Agente (Opcional):

Após concluir a interação com o agente, você pode encerrá-lo para liberar os recursos associados. Você pode fazer isso em uma célula separada:

```elixir
# Encerre o agente
:ok = Agent.stop(agent)
```

# Exercício

# Links

Se você quiser saber mais, recomendamos abaixo alguns links que podem ser úteis:
- [Elixir School](https://elixirschool.com/pt) - Site que contém várias "lições" em português.
- Livros
- Vídeos (eu e ElixirLab)
- Cursos (Groxio, ElxPro, Rafa Camarda)
- Comunidade Telegram
