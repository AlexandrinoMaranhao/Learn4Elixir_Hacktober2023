# Learn4Elixir - Capítulo 4

Neste Capitulo você irá aprender sobre: Data e Tempo, Processos em Elixir e Agentes.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter4.livemd)

# Data e Tempo 

O Elixir tem alguns módulos que trabalham com tempo. Ainda que precise ser notado que essa funcionalidade é limitada para trabalhar com fuso horário UTC.

Vamos começar pegando o tempo atual:

```elixir
iex> Time.utc_now
~T[19:39:31.056226]
```

Note que nós vamos ter um sigil que pode ser usado para criar uma struct Time também:

```elixir
iex> ~T[19:39:31.056226]
~T[19:39:31.056226]
```

Você pode aprender mais sobre sigil na lição sobre sigils. É fácil acessar partes desta struct:

```elixir
iex> t = ~T[19:39:31.056226]
~T[19:39:31.056226]
iex> t.hour
19
iex> t.minute
39
iex> t.day
** (KeyError) key :day not found in: ~T[19:39:31.056226]
```

Mas há uma pegadinha: como você pode ter notado, essa struct contém apenas tempo de um dia, dados de dia/mês/ano não estão presentes.

## Date

Ao contrário do Time, a struct Date tem as informações sobre a data sem nenhuma informação sobre o tempo.

```elixir
iex> Date.utc_today
~D[2028-10-21]
```

Mas ele tem algumas funções úteis para trabalhar com datas:

```elixir
iex> {:ok, date} = Date.new(2020, 12, 12)
{:ok, ~D[2020-12-12]}
iex> Date.day_of_week date
6
iex> Date.leap_year? date
true
```

day_of_week/1 calcula em que dia da semana será a data provida. Nesse caso é um sábado. leap_year?/1 verifica se é um ano bissexto. Outras funções podem ser encontradas na documentação.

## NaiveDateTime

Há dois tipos de structs que contém tanto a data e o tempo em apenas um lugar no Elixir. O primeiro dos dois é o NaiveDateTime. A desvantagem é a falta de suporte para fuso horário:

```elixir
iex> NaiveDateTime.utc_now
~N[2022-01-21 19:55:10.008965]
```

Mas ele tem tanto o tempo como a data, então você pode adicionar tempo, por exemplo:

```elixir
iex> NaiveDateTime.add(~N[2018-10-01 00:00:14], 30)
~N[2018-10-01 00:00:44]
```

## DateTime

O segundo, como você pode ter adivinhado a partir do título dessa seção, é DateTime. Não possui as limitações mencionadas no NaiveDateTime: possui data e hora e suporta fusos horários. Mas esteja ciente dos fusos horários. A documentação oficial fala:

 Muitas funções neste módulo requerem um fuso horário do banco de dados. Por padrão, é utilizado o fuso horário do banco de dados que é retornado pela função Calendar.get_time_zone_database/0, cujo padrão é Calendar.UTCOnlyTimeZoneDatabase, que lida apenas com as datas “Etc/UTC” e retorna {:error, :utc_only_time_zone_database} para qualquer outro fuso horário. 

Também, note que você pode criar um instância de DateTime a partir de um NaiveDateTime, apenas fornecendo o fuso horário:

```elixir
iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], "Etc/UTC")
{:ok, #DateTime<2016-05-24 13:26:08.003Z>}
```

## Trabalhando com Timezones

Como observamos na seção anterior, por padrão, o Elixir não possui dados de fuso horário. Para resolver esse problema, precisamos instalar e configurar o pacote tzdata. Após a instalação, você deve configurar globalmente o Elixir para usar o Tzdata com o fuso horário do banco de dados:

```elixir
config :elixir, :time_zone_database, Tzdata.TimeZoneDatabase
```

Agora, vamos tentar criar um horário no fuso horário de Paris e convertê-lo para o horário de Nova York:

```elixir
iex> paris_datetime = DateTime.from_naive!(~N[2019-01-01 12:00:00], "Europe/Paris")
#DateTime<2019-01-01 12:00:00+01:00 CET Europe/Paris>
iex> {:ok, ny_datetime} = DateTime.shift_zone(paris_datetime, "America/New_York")
{:ok, #DateTime<2019-01-01 06:00:00-05:00 EST America/New_York>}
iex> ny_datetime
#DateTime<2019-01-01 06:00:00-05:00 EST America/New_York>
```

Como você pode ver, a hora mudou de 12:00 em Paris para às 6:00 em Nova York, o que é correto - a diferença no fuso horário entre as duas cidades é de 6 horas.

# Processos em Elixir

No Livebook, você pode usar processos em Elixir da mesma forma que faria em um ambiente Elixir tradicional. Os processos são a principal unidade de concorrência em Elixir e permitem que você execute tarefas em paralelo, compartilhe dados e crie sistemas concorrentes. Aqui estão alguns exemplos de como usar processos no Livebook:

## Criar um Processo:

Para criar um processo em Elixir, você pode usar a função spawn/1 ou Task.start/1. Aqui está um exemplo usando Task.start/1 para criar um processo que imprime "Hello, World!" após um atraso de 2 segundos:

```elixir
task = Task.start(fn ->
  :timer.sleep(2000)
  IO.puts("Hello, World!")
end)
```

## Aguardar o Término do Processo:

Você pode usar Task.await/2 para aguardar o término de um processo criado com Task.start/1:

```elixir
Task.await(task)
```

Isso fará com que o processo principal espere até que o processo da tarefa seja concluído.

## Enviar e Receber Mensagens entre Processos:

Os processos em Elixir podem se comunicar entre si por meio do envio e recebimento de mensagens. Você pode usar a função send/2 para enviar mensagens e receive/1 para receber mensagens. Aqui está um exemplo de envio e recebimento de mensagens entre dois processos:

```elixir
pid = spawn(fn ->
  send(self(), {:message, "Hello from another process!"})
end)

receive do
  {:message, message} ->
    IO.puts("Mensagem Recebida: #{message}")
end
```

## Encerrar um Processo:

Você pode encerrar um processo usando a função Process.exit/2 ou deixando que ele termine naturalmente. Por exemplo, para encerrar um processo com uma mensagem de saída:

```elixir
Process.exit(pid, :shutdown)
```

## Supervisionar Processos (opcional):

Em sistemas mais complexos, você pode usar o mecanismo de supervisão do Elixir para monitorar e gerenciar processos automaticamente. Isso ajuda a criar sistemas resilientes que podem se recuperar de falhas.

Para criar um supervisor e gerenciar processos, você pode usar o módulo Supervisor. No entanto, a criação de supervisores requer um ambiente mais complexo e pode não ser adequada para exemplos simples no Livebook.

Lembre-se de que o Livebook permite que você execute células em qualquer ordem e que as células podem representar unidades independentes de código. Portanto, você pode experimentar a criação, envio de mensagens e interação com processos em células diferentes para entender melhor como os processos funcionam em Elixir. Certifique-se de que suas células estejam configuradas para serem executáveis para ver os resultados da interação com processos no Livebook.

# Agentes

Para usar agentes no Livebook, você pode seguir os mesmos princípios que aplicaria em um ambiente Elixir tradicional. Agentes são uma maneira de compartilhar e gerenciar estado em ambientes concorrentes de forma segura. Aqui está um exemplo de como usar agentes no Livebook:

### Inicialize um Agente (Servidor):

Comece inicializando um agente que conterá o estado que você deseja compartilhar. Você pode fazer isso em uma célula do Livebook:

```elixir
# Inicialize um agente com um estado inicial
{:ok, agent} = Agent.start(fn -> 0 end)
```

Neste exemplo, o agente é inicializado com um estado inicial de 0.

### Crie Funções de Cliente:

Em seguida, você pode criar funções de cliente que interagem com o agente para ler ou atualizar seu estado. Você pode definir essas funções em células separadas:

```elixir
# Função para ler o estado do agente
defp get_state(agent) do
  Agent.get(agent, fn state -> state end)
end

# Função para atualizar o estado do agente

defp update_state(agent, new_state) do
  Agent.update(agent, fn _state -> new_state end)
end
```

### Interaja com o Agente:

Agora você pode usar as funções do cliente para interagir com o agente em células subsequentes do Livebook:

```elixir
# Use o cliente para ler o estado atual do agente
current_state = get_state(agent)
IO.puts("Estado Atual: #{current_state}")

# Atualize o estado do agente usando o cliente
new_state = current_state + 1
update_state(agent, new_state)
IO.puts("Estado Atualizado: #{new_state}")
```

### Encerre o Agente (Opcional):

Após concluir a interação com o agente, você pode encerrá-lo para liberar os recursos associados. Você pode fazer isso em uma célula separada:

```elixir
# Encerre o agente
:ok = Agent.stop(agent)
```

Lembre-se de que o Livebook permite que você execute células em qualquer ordem, o que facilita a experimentação e a interação com agentes e estados compartilhados. Certifique-se de que suas células estejam configuradas para serem executáveis para ver os resultados da interação com agentes no Livebook.

## Exercício
