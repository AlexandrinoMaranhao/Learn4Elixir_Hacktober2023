# Capítulo 2

## Funções sem nome (anônimas)

Agora que você já sabe o que são funções, vamos falar pra você de um tipo de função que pode ser muito útil em alguns casos: as funções sem nome (também chamadas de "funções anônimas").

<!-- livebook:{"break_markdown":true} -->

Funções anônimas são funções que, como o próprio nome diz, não têm um nome. Elas são descritas apenas definindo qual sua entrada (se alguma) e os comandos que vão produzir sua saída.

<!-- livebook:{"break_markdown":true} -->

No exemplo abaixo, definimos uma função que recebe um valor 'num' (que representa um número) e retorna este número adicionado de 1.

```elixir
fn num -> num + 1 end
```
<!-- livebook:{"break_markdown":true} -->

Quando você avalia o código acima, você percebe que Elixir te dá algo como:

```
#Function<42.125776118/1 in :erl_eval.expr/6>
```

Este valor, por si só, não tem muita utilidade para nós.

<!-- livebook:{"break_markdown":true} -->

Como então podemos aplicar a função anônima que acabamos de definir a um valor, como 2? Normalmente não fazemos isso em Elixir, mas uma solução é atribuir a função a uma variável. 

```elixir
f = fn num -> num + 1 end
```

E só depois chamar a função:
```elixir
f.(2)
```

Perceberam que, para chamar a função 'f', precisamos colocar um ponto antes dos parênteses? É uma característica de Ellxir (que na prática não é um problema).

<!-- livebook:{"break_markdown":true} -->
Outra forma é fazer a chamada diretamente (também usando o ponto):

```elixir
(fn num -> num + 1 end).(2)
```

## Exercício

Escreva uma função anônima que retorna o argumento que for passado a ela (função identidade):

```elixir
fn 
```

## Funções de ordem mais alta

O uso realmente interessante de funções anônimas é em funções de ordem mais alta (_higher-order functions_). Funções de ordem mais alta recebem uma ou mais funções como argumento, ou retornam uma função.

## O módulo Enum

O [módulo Enum](https://elixirschool.com/pt/lessons/basics/enum) inclui várias funções de ordem mais alta. 

<!-- livebook:{"break_markdown":true} -->
Por exemplo, a função 'Enum.map/2' recebe, no exemplo abaixo, como entrada uma lista '[10, 20, 3, 45]' e uma função anônima de aridade 1 que soma 12 ao valor que receber:

```elixir
Enum.map([10, 20, 3, 45], fn(x) -> x + 12 end)
```

A função 'Enum.reduce/2' recebe como argumento uma lista, um valor inicial e uma função de aridade 2. No exemplo abaixo, a lista é '[1, 2,3]', o valor inicial é 0 e a função soma um elemento da lista ao acumulador, que passa a ter o valor desta soma. Deste modo, o resultado será '0+1+2+3'. 

```elixir
Enum.reduce([1, 2, 3], 0, fn(elemento, acumulador) -> elemento + acumulador end)
```

E como seria um exemplo de uma função que retorna outra função?
No módulo abaixo nós definimos uma função 'HOF.incrementador/1', que recebe como entrada um número e retorna uma função de aridade 1 que incrementa um outro valor a este número.
```elixir
defmodule HOF do
  def incrementador(numero) do
     fn valor -> valor + numero end
  end
end
```
Ou seja, se eu chamar desta forma:
```elixir
HOF.incrementador(3)
```
Eu obtenho uma função que incrementa 3 ao valor que receber. Portanto, se eu passar 5 a esta função, o resultado será 8.

```elixir
(HOF.incrementador(3)).(5)
```

É útil? Não lembro de nenhuma utilidade deste tipo de função em meu código. Mas pode ser útil em bibliotecas bem específicas. 


## O operador Pipe

O operador pipe (representado pelos dois símbolos '|>') é uma forma de chamar funções que permite que as chamadas sejam encadeadas de uma forma elegante e prática.

<!-- livebook:{"break_markdown":true} -->

Por exemplo, em vez de fazer:


```elixir
require Integer
Enum.all?(Enum.map([1,2,3,4], fn x->x*2 end), &Integer.is_even/1)
```
Podemos escrever:

```elixir
require Integer
[1,2,3,4]
|> Enum.map(fn x->x*2 end)
|> Enum.all?(&Integer.is_even/1)
```

Ou seja, o pipe envia o resultado de uma expressão como o primeiro parâmetro para a próxima chamada a função. 

## Funções privadas em Módulos

Uma funcionalidade que pode ser útil é a definição de funções privadas em módulos.

<!-- livebook:{"break_markdown":true} -->

Nós vimos anteriormente como definir uma função em um módulo:
```elixir
defmodule Matematica do
  def media(num1, num2) do
      (num1+num2)/2
  end
end
```

Vamos supor que eu queira ter uma função auxiliar, uma função que é usada apenas pelas outras funções do módulo. Este é o caso em que definimos uma função previada e para isso, em vez de 'def', usamos 'defp'.

```elixir
defmodule Matematica do
  def media(num1, num2) do
      (num1+num2)/2
  end

  def fatorial(num) when num>0 do
     fatorial(num,1)
  end
  def fatorial(_num)  do
     :error
  end
  defp fatorial(num, num) do
    num
  end
  defp fatorial(num, ) do
    
end


## Links

Se você quiser saber mais, recomendamos abaixo alguns links que podem ser úteis:
- [Elixir School](https://elixirschool.com/pt) - Site que contém várias "lições" em português.
- Livros
- Vídeos (eu e ElixirLab)
- Cursos (Groxio, ElxPro, Rafa Camarda)
- Comunidade Telegram
