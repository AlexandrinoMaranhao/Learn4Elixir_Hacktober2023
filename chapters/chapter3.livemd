## Estruturas de controle 

### If e Unless
Existem chances de que você já tenha encontrado if/2 antes, e caso você tenha utilizado Ruby você é familiarizado com unless/2. Em Elixir eles trabalham praticamente da mesma forma porém são definidos como macros, não construtores da linguagem; Você pode encontrar a implementação deles em Kernel module.

Pode-se notar que em Elixir, os únicos valores falsos são nil e o booleano false.

```elixir
iex> if String.valid?("Hello") do
...>  "Valid string!"
...> else
...>   "Invalid string."
...> end
"Valid string!"

iex> if "a string value" do
...>   "Truthy"
...> end
"Truthy"
```

Usar unless/2 é bem parecido com o uso do if/2 porém trabalhando de forma negativa:

```elixir
iex> unless is_integer("hello") do
...>   "Not an Int"
...> end
"Not an Int"
```
### Case
Caso seja necessário combinar múltiplos padrões nós poderemos utilizar case/2:

```elixir
iex> case {:ok, "Hello World"} do
...>  {:ok, result} -> result
...>  {:error} -> "Uh oh!"
...>  _ -> "Catch all"
...> end
"Hello World"
```

A variável _ é uma importante inclusão na declaração do case/2. Sem isso a falha em procura de combinação iria causar um erro:

```elixir
iex> case :even do
...>   :odd -> "Odd"
...> end
** (CaseClauseError) no case clause matching: :even

iex> case :even do
...>  :odd -> "Odd"
...>  _ -> "Not Odd"
...> end
"Not Odd"
```

Considere _ como o else que irá igualar com “todo o resto”. Já que case/2 depende de combinação de padrões, todas as mesmas regras e restrições são aplicadas. Se você pretende procurar padrões em variáveis que já existem, você irá precisar utilizar o operador pin ^/1:

```elixir
iex> pie = 3.14
3.14
...> case "cherry pie" do
...>  ^pie -> "Not so tasty"
...>   pie -> "I bet #{pie} is tasty"
...> end
"I bet cherry pie is tasty"
```

Outra característica interessante do case/2 é o seu suporte para cláusulas de guarda:

Este exemplo vem diretamente do Guia Introdutório oficial do Elixir.

```elixir
iex> case {1, 2, 3} do
...>  {1, x, 3} when x > 0 ->
...>     "Will match"
...>   _ ->
...>     "Won't match"
...> end
"Will match"
```

Verifique a documentação oficial sobre Expressões permitidas em cláusulas guard.

### Cond
Quando necessitamos associar condições, e não valores, nós podemos recorrer ao cond/1; Isso é semelhante ao else if ou elsif de outras linguagens:

Este exemplo vem diretamente do Guia Introdutório oficial do Elixir.

```elixir
iex> cond do
...>   2 + 2 == 5 ->
...>     "This will not be true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   1 + 1 == 2 ->
...>     "But this will"
...> end
"But this will"
```
Como case/2, cond/1 irá gerar um erro caso não seja achado associação. Para lidar com isso, nós podemos definir a condição para true:

```elixir
iex> cond do
...>   7 + 1 == 0 -> "Incorrect"
...>   true -> "Catch all"
...> end
"Catch all"
```
### With
A forma especial with/1 é útil quando tentamos usar case/2 de maneira aninhada ou em situações que não é possível encadear funções. A expressão with/1 é composta de palavras-chaves, generators e finalmente uma expressão.

Iremos discutir generators na lição sobre list comprehensions para comparar o lado direito do operador <- com o lado esquerdo.

Vamos começar com um exemplo simples de with/1 e então vamos olhar em algo mais:

```elixir
iex> user = %{first: "Sean", last: "Callan"}
...> %{first: "Sean", last: "Callan"}
...> with {:ok, first} <- Map.fetch(user, :first),
...>      {:ok, last} <- Map.fetch(user, :last),
...>      do: last <> ", " <> first
"Callan, Sean"
```

Quando uma expressão falha em achar um padrão, o valor da expressão que falhou será retornado:

```elixir
iex> user = %{first: "doomspork"}
...> %{first: "doomspork"}
...> with {:ok, first} <- Map.fetch(user, :first),
 ...>     {:ok, last} <- Map.fetch(user, :last),
 ...>     do: last <> ", " <> first
:error
```

Agora vamos olhar um exemplo maior sem with/1 e então ver como nós podemos refatorar:

```elixir
iex> case Repo.insert(changeset) do
...>   {:ok, user} ->
...>     case Guardian.encode_and_sign(user, :token, claims) do
...>       {:ok, token, full_claims} ->
...>         important_stuff(token, full_claims)

...>       error ->
...>         error
...>     end

...>   error ->
...>     error
...> end
```

Quando utilizamos with/1 acabamos com um código que é facilmente entendido e possui menos linhas:

```elixir
iex> with {:ok, user} <- Repo.insert(changeset),
...>      {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
...>   important_stuff(token, full_claims)
...> end
```

A partir do Elixir 1.3, with/1 suporta else:

```elixir
iex> import Integer

...> m = %{a: 1, c: 3}

...> a =
...>   with {:ok, number} <- Map.fetch(m, :a),
...>     true <- is_even(number) do
...>       IO.puts "#{number} divided by 2 is #{div(number, 2)}"
...>       :even
...>   else
...>     :error ->
...>       IO.puts("We don't have this item in map")
...>       :error

...>     _ ->
...>       IO.puts("It is odd")
...>       :odd
...>   end
```

Isso ajuda a lidar com erros provendo padrões parecido com o case. O valor passado para o else é o primeiro que não foi correspondido com o padrão em uma expressão.

## Sigils

Elixir fornece uma sintaxe alternativa para representar e trabalhar com literais. Um sigil (símbolo especial) vai começar com um til ~ seguido por um caractere. O núcleo do Elixir fornece-nos alguns sigils, no entanto, é possível criar o nosso próprio quando precisamos estender a linguagem.

Uma lista de sigils disponíveis incluem:

- ~C Gera uma lista de caracteres sem escape ou interpolação
- ~c Gera uma lista de caracteres com escape e interpolação
- ~R Gera uma expressão regular sem escape ou interpolação
- ~r Gera uma expressão regular com escape e interpolação
- ~S Gera strings sem escape ou interpolação
- ~s Gera string com escape e interpolação
- ~W Gera uma lista sem escape ou interpolação
- ~w Gera uma lista com escape e interpolação
- ~N Gera uma NaiveDateTime struct

Uma lista de delimitadores inclui:

- <...> Um par de brackets
- {...} Um par de chaves
- [...] Um par de colchetes
- (...) Um par de parênteses
- |...| Um par de pipes
- /.../ Um par de barras
- "..." Um par de aspas duplas
- '...' Um par de aspas simples

### Lista de Caracteres

O ~c e ~C sigils geram listas de caracteres respectivamente. Por exemplo:

```elixir
iex> ~c/2 + 7 = #{2 + 7}/
'2 + 7 = 9'

iex> ~C/2 + 7 = #{2 + 7}/
'2 + 7 = \#{2 + 7}'
```

Podemos ver em letra minúscula ~c interpolando o cálculo, enquanto um sigil de letra maiúscula ~C não. Veremos que esta sequência maiúscula / minúscula é um tema comum em toda a construção de sigils.

### Expressões Regulares

O ~r e ~R sigils são usados para representar Expressões Regulares. Nós criamos ambos dentro de funções Regex. Por exemplo:

```elixir
iex> re = ~r/elixir/
~r/elixir/

iex> "Elixir" =~ re
false

iex> "elixir" =~ re
true
```

Podemos ver que no primeiro teste de igualdade, Elixir não coincide com a expressão regular. Isso acontece porque ele está utilizando letra maiúscula. Pelo fato de Elixir suportar expressões regulares compatíveis com Perl (PCRE), podemos acrescentar i ao final do nosso sigil para ligar maiúsculas e minúsculas.

```elixir
iex> re = ~r/elixir/i
~r/elixir/i

iex> "Elixir" =~ re
true

iex> "elixir" =~ re
true
```

Além disso, Elixir fornece a API Regex, que é construída em cima da biblioteca de expressão regular do Erlang. Vamos implementar Regex.split/2 usando um sigil regex.

```elixir
iex> string = "100_000_000"
"100_000_000"

iex> Regex.split(~r/_/, string)
["100", "000", "000"]
```

Como podemos ver, a string "100_000_000" é dividida nas barras sublinhadas graças ao nosso ~r/_/ sigil. A função Regex.split retorna uma lista.

### String
O ~s e ~S sigils são usados para gerar dados de String. Por exemplo:

```elixir
iex> ~s/the cat in the hat on the mat/
"the cat in the hat on the mat"

iex> ~S/the cat in the hat on the mat/
"the cat in the hat on the mat"
```

Mas qual é a diferença? A diferença é semelhante ao sigil da lista de palavras em que estamos procurando. A resposta é interpolação e o uso de sequências de escape. Se pegarmos outro exemplo:

```elixir
iex> ~s/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir school"

iex> ~S/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir \#{String.downcase \"SCHOOL\"}"
```

### Lista de Palavras

A lista de palavras do tipo sigil pode ser muito útil. Pode lhe economizar tempo, digitação e possivelmente, reduzir a complexidade dentro da base de código. Veja este exemplo simples:

```elixir
iex> ~w/i love elixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love elixir school/
["i", "love", "elixir", "school"]
```

Podemos ver que o que é digitado entre os delimitadores é separado por espaços em branco em uma lista. No entanto, não existe qualquer diferença entre estes dois exemplos. Novamente, a diferença vem com as seguintes sequências de interpolação e escape. Veja o seguinte exemplo:

```elixir
iex> ~w/i love #{'e'}lixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love #{'e'}lixir school/
["i", "love", "\#{'e'}lixir", "school"]
```

### NaiveDateTime

Uma NaiveDateTime pode ser bem útil para criar rapidamente uma struct que representa um DateTime sem um timezone.

Geralmente, nós devemos evitar criar uma NaiveDateTime struct diretamente. No entanto, é muito útil para pattern matching. Por exemplo:

```elixir
iex> NaiveDateTime.from_iso8601("2015-01-23 23:50:07") == {:ok, ~N[2015-01-23 23:50:07]}
```
### Criando Sigils

Um dos objetivos do Elixir é ser uma linguagem de programação extensível. Não é surpresa então que você possa facilmente criar o seu próprio sigil customizado. Neste exemplo, vamos criar um sigil para converter uma cadeia para letras maiúsculas. Como já existe uma função para isso no núcleo do Elixir (String.upcase/1), vamos embrulhar o nosso sigil em torno desta função.

```elixir
iex> defmodule MySigils do
...>  def sigil_u(string, []), do: String.upcase(string)
...> end

iex> import MySigils
nil

iex> ~u/elixir school/
ELIXIR SCHOOL
```

Primeiro definimos um módulo chamado MySigils e dentro deste módulo, criamos uma função chamada sigil_u. Como não existe nenhum sigil ~u no espaço de sigil existente, vamos usá-lo. O _u indica que desejamos usar u como caractere depois do til. A definição da função deve receber dois argumentos, uma entrada e uma lista.

## Mais sobre módulos 

Os módulos permitem a organização de funções em um namespace. Além de agrupar funções, eles permitem definir funções nomeadas e privadas que cobrimos na lição sobre funções.

Vejamos um exemplo básico:

```elixir
iex> defmodule Example do
...>  def greeting(name) do
...>     "Hello #{name}."
...>   end
...> end

iex> Example.greeting "Sean"
"Hello Sean."
```

É possível aninhar módulos em Elixir, permitindo-lhe promover um namespace para a sua funcionalidade:

```elixir
iex> defmodule Example.Greetings do
...>   def morning(name) do
...>     "Good morning #{name}."
...>   end

...>   def evening(name) do
...>     "Good night #{name}."
...>   end
...> end


iex> Example.Greetings.morning "Sean"
"Good morning Sean."
```

### Atributos de Módulo
Atributos de módulo são mais comumente usados como constantes no Elixir. Vamos dar uma olhada em um exemplo simples:

```elixir
iex> defmodule Example do
...>   @greeting "Hello"

...>   def greeting(name) do
...>     ~s(#{@greeting} #{name}.)
...>   end
...> end
```

É importante notar que existem atributos reservados no Elixir. Os três mais comuns são:

- moduledoc — Documenta o módulo atual.
- doc — Documentação para funções e macros.
- behaviour — Usa um OTP ou comportamento definido.

### Structs
Structs são mapas especiais com um conjunto definido de chaves e valores padrões. Ele deve ser definido dentro de um módulo, no qual leva o nome dele. É comum para um struct ser a única coisa definido dentro de um módulo.

Para definir um struct nós usamos defstruct juntamente com uma lista de palavra-chave de campos e valores padrões:

```elixir 
iex> defmodule Example.User do
...>  defstruct name: "Sean", roles: []
...> end
```

Vamos criar algumas structs:

```elixir
iex> %Example.User{}
%Example.User<name: "Sean", roles: [], ...>

iex> %Example.User{name: "Steve"}
%Example.User<name: "Steve", roles: [], ...>

iex> %Example.User{name: "Steve", roles: [:manager]}
%Example.User<name: "Steve", roles: [:manager]>
```

Podemos atualizar nosso struct apenas como se fosse um mapa:

```elixir
iex> steve = %Example.User{name: "Steve"}
%Example.User<name: "Steve", roles: [...], ...>
iex> sean = %{steve | name: "Sean"}
%Example.User<name: "Sean", roles: [...], ...>
```

Mais importante, você pode associar estruturas contra mapas:

```elixir
iex> %{name: "Sean"} = sean
%Example.User<name: "Sean", roles: [...], ...>
```

A partir do Elixir 1.8, structs incluem introspecção customizáveis. Para entender o que isso significa e como devemos usar, vamos inspecionar nossa captura sean:

```elxiir
iex> inspect(sean)
"%Example.User<name: \"Sean\", roles: [...], ...>"
```

Todos os campos estão presentes, o que está correto para esse exemplo, mas o que acontece se tivéssemos um campo protegido que não gostaríamos de incluir? A nova funcionalidade @derive faz com que possamos alcançar isso! Vamos atualizar nosso exemplo para que roles não seja mais incluído na nossa saída:

```elixir
iex> defmodule Example.User do
...>   @derive {Inspect, only: [:name]}
...>   defstruct name: nil, roles: []
...> end
```

Nota: podemos também usar @derive {Inspect, except: [:roles]}, que é equivalente.

Com o nosso módulo já atualizado, vamos ver o que acontece no iex:

```elixir
iex> sean = %Example.User{name: "Sean"}
%Example.User<name: "Sean", ...>
iex> inspect(sean)
"%Example.User<name: \"Sean\", ...>"
```

Os roles não são mais exibidos na saída!

### Composição
Agora que sabemos como criar módulos e structs, vamos aprender a incluir uma funcionalidade existente neles através da composição. Elixir nos fornece uma variedade de maneiras diferentes para interagir com outros módulos, vamos ver o que temos à nossa disposição.

### Alias
Permite-nos criar pseudônimos, usado frequentemente em código Elixir:

```elixir
iex> defmodule Sayings.Greetings do
...>   def basic(name), do: "Hi, #{name}"
...> end

...> defmodule Example do
...>   alias Sayings.Greetings

...>   def greeting(name), do: Greetings.basic(name)
...> end

# Sem alias

iex> defmodule Example do
...>   def greeting(name), do: Sayings.Greetings.basic(name)
...> end
```

Se houver um conflito com dois aliases ou você deseja criar um pseudônimo para um nome completamente diferente, podemos usar a opção :as:

```elixir
iex> defmodule Example do
...>  alias Sayings.Greetings, as: Hi

..>  def print_message(name), do: Hi.basic(name)
...> end
```

É possível criar pseudônimos para múltiplos módulos de uma só vez:

```elixir
iex> defmodule Example do
...>  alias Sayings.{Greetings, Farewells}
..> end
```

### Import
Se queremos importar funções em vez de criar pseudônimos de um módulo, podemos usar import:

```elixir
iex> last([1, 2, 3])
** (CompileError) iex:9: undefined function last/1
iex> import List
nil
iex> last([1, 2, 3])
3
```

### Filtrando
Por padrão todas as funções e macros são importadas, porém nós podemos filtrá-los usando as opções :only e :except.

Para importar funções e macros específicos nós temos que fornecer os pares de nome para :only e :except. Vamos começar por importar apenas a função last/1:

```elixir
iex> import List, only: [last: 1]
iex> first([1, 2, 3])
** (CompileError) iex:13: undefined function first/1
iex> last([1, 2, 3])
3
```

Se nós importarmos tudo, exceto last/1 e tentar as mesmas funções como antes:

```elixir
iex> import List, except: [last: 1]
nil
iex> first([1, 2, 3])
1
iex> last([1, 2, 3])
** (CompileError) iex:3: undefined function last/1
```

Além do par nome/aridade existem dois átomos especiais, :functions e :macros, que importam apenas funções e macros, respectivamente:

```elixir
iex> import List, only: :functions
iex> import List, only: :macros
```

### Require
Nós podemos usar require para dizer ao Elixir que vamos usar macros de outro módulo. A pequena diferença com import é que ele permite usar macros, mas não funções do módulo especificado.

```elixir
iex> defmodule Example do
...>  require SuperMacros

...>  SuperMacros.do_stuff
...> end
```

Se tentar chamar um macro que ainda não está carregado, Elixir vai gerar um erro.

### Use
Com a macro use podemos dar habilidade a outro módulo para modificar a sua definição atual. Quando invocamos use em nosso código estamos invocando o callback __using__/1 definido pelo módulo declarado. O resultado da macro __using__/1 passa a fazer parte da definição do módulo. Para melhor entendimento de como isso funciona vamos olhar um exemplo simples:

```elxiir
iex> defmodule Hello do
...>  defmacro __using__(_opts) do
...>    quote do
...>      def hello(name), do: "Hi, #{name}"
...>    end
...>   end
...>  end
```

Aqui criamos um módulo Hello que define o callback __using__/1, o qual define a função hello/1. Vamos criar um novo módulo para tentar nosso novo código:

```elixir
iex> defmodule Example do
...>  use Hello
...> end
```

Se executarmos nosso código no IEx veremos que hello/1 está disponível no módulo Example.

```elixir
iex> Example.hello("Sean")
"Hi, Sean"
```

Aqui podemos ver que use invoca o callback __using__/1 dentro do Hello o qual acaba adicionando o código dentro do nosso módulo. Agora que demonstramos o exemplo básico vamos atualizar nosso código para entender como __using__/1 suporta opções. Vamos fazer isso adicionando a opção greeting:

```elixir
iex> defmodule Hello do
...>  defmacro __using__(opts) do
...>    greeting = Keyword.get(opts, :greeting, "Hi")

...>    quote do
...>      def hello(name), do: unquote(greeting) <> ", " <> name
...>    end
...>  end
...> end
```

Vamos atualizar nosso módulo Example para incluir a opção nova greeting:

```elixir
iex> defmodule Example do
...>  use Hello, greeting: "Hola"
...> end
```

Se executamos isso dentro do IEx devemos ver que a função greeting foi alterada:

```elixir
iex> Example.hello("Sean")
"Hola, Sean"
```

Esses exemplos simples demonstram como use funciona, mas essa é uma ferramenta poderosa na caixa de ferramentas do Elixir. À medida que você passa a aprender mais sobre Elixir, você observa bem como o use é utilizado. Um exemplo que você verá com certeza é use ExUnit.Case, async: true.

## Compreensões

https://elixirschool.com/pt/lessons/basics/comprehensions

## Exercícios
