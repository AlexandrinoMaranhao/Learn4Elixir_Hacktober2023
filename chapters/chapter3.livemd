# Learn4Elixir - Capítulo 3

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter3.livemd)

Neste capitulo iremos nos aprofundar em Estruturas de Controle.

## Estruturas de Controle 

## If e Unless

Existem chances de que você já tenha encontrado if/2 antes, e caso você tenha utilizado Ruby você é familiarizado com unless/2. Em Elixir eles trabalham praticamente da mesma forma porém são definidos como macros, não construtores da linguagem; Você pode encontrar a implementação deles em Kernel module.

Pode-se notar que em Elixir, os únicos valores falsos são nil e o booleano false.

```elixir
iex> if String.valid?("Hello") do
...>  "Valid string!"
...> else
...>   "Invalid string."
...> end
"Valid string!"

iex> if "a string value" do
...>   "Truthy"
...> end
"Truthy"
```

Usar unless/2 é bem parecido com o uso do if/2 porém trabalhando de forma negativa:

```elixir
iex> unless is_integer("hello") do
...>   "Not an Int"
...> end
"Not an Int"
```
## Case

Caso seja necessário combinar múltiplos padrões nós poderemos utilizar case/2:

```elixir
iex> case {:ok, "Hello World"} do
...>  {:ok, result} -> result
...>  {:error} -> "Uh oh!"
...>  _ -> "Catch all"
...> end
"Hello World"
```

A variável _ é uma importante inclusão na declaração do case/2. Sem isso a falha em procura de combinação iria causar um erro:

```elixir
iex> case :even do
...>   :odd -> "Odd"
...> end
** (CaseClauseError) no case clause matching: :even

iex> case :even do
...>  :odd -> "Odd"
...>  _ -> "Not Odd"
...> end
"Not Odd"
```

Considere _ como o else que irá igualar com “todo o resto”. Já que case/2 depende de combinação de padrões, todas as mesmas regras e restrições são aplicadas. Se você pretende procurar padrões em variáveis que já existem, você irá precisar utilizar o operador pin ^/1:

```elixir
iex> pie = 3.14
3.14
...> case "cherry pie" do
...>  ^pie -> "Not so tasty"
...>   pie -> "I bet #{pie} is tasty"
...> end
"I bet cherry pie is tasty"
```

Outra característica interessante do case/2 é o seu suporte para cláusulas de guarda:

Este exemplo vem diretamente do Guia Introdutório oficial do Elixir.

```elixir
iex> case {1, 2, 3} do
...>  {1, x, 3} when x > 0 ->
...>     "Will match"
...>   _ ->
...>     "Won't match"
...> end
"Will match"
```

Verifique a documentação oficial sobre Expressões permitidas em cláusulas guard.

## Cond

Quando necessitamos associar condições, e não valores, nós podemos recorrer ao cond/1; Isso é semelhante ao else if ou elsif de outras linguagens:

Este exemplo vem diretamente do Guia Introdutório oficial do Elixir.

```elixir
iex> cond do
...>   2 + 2 == 5 ->
...>     "This will not be true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   1 + 1 == 2 ->
...>     "But this will"
...> end
"But this will"
```
Como case/2, cond/1 irá gerar um erro caso não seja achado associação. Para lidar com isso, nós podemos definir a condição para true:

```elixir
iex> cond do
...>   7 + 1 == 0 -> "Incorrect"
...>   true -> "Catch all"
...> end
"Catch all"
```
## With

A forma especial with/1 é útil quando tentamos usar case/2 de maneira aninhada ou em situações que não é possível encadear funções. A expressão with/1 é composta de palavras-chaves, generators e finalmente uma expressão.

Iremos discutir generators na lição sobre list comprehensions para comparar o lado direito do operador <- com o lado esquerdo.

Vamos começar com um exemplo simples de with/1 e então vamos olhar em algo mais:

```elixir
iex> user = %{first: "Sean", last: "Callan"}
...> %{first: "Sean", last: "Callan"}
...> with {:ok, first} <- Map.fetch(user, :first),
...>      {:ok, last} <- Map.fetch(user, :last),
...>      do: last <> ", " <> first
"Callan, Sean"
```

Quando uma expressão falha em achar um padrão, o valor da expressão que falhou será retornado:

```elixir
iex> user = %{first: "doomspork"}
...> %{first: "doomspork"}
...> with {:ok, first} <- Map.fetch(user, :first),
 ...>     {:ok, last} <- Map.fetch(user, :last),
 ...>     do: last <> ", " <> first
:error
```

Agora vamos olhar um exemplo maior sem with/1 e então ver como nós podemos refatorar:

```elixir
iex> case Repo.insert(changeset) do
...>   {:ok, user} ->
...>     case Guardian.encode_and_sign(user, :token, claims) do
...>       {:ok, token, full_claims} ->
...>         important_stuff(token, full_claims)

...>       error ->
...>         error
...>     end

...>   error ->
...>     error
...> end
```

Quando utilizamos with/1 acabamos com um código que é facilmente entendido e possui menos linhas:

```elixir
iex> with {:ok, user} <- Repo.insert(changeset),
...>      {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
...>   important_stuff(token, full_claims)
...> end
```

A partir do Elixir 1.3, with/1 suporta else:

```elixir
iex> import Integer

...> m = %{a: 1, c: 3}

...> a =
...>   with {:ok, number} <- Map.fetch(m, :a),
...>     true <- is_even(number) do
...>       IO.puts "#{number} divided by 2 is #{div(number, 2)}"
...>       :even
...>   else
...>     :error ->
...>       IO.puts("We don't have this item in map")
...>       :error

...>     _ ->
...>       IO.puts("It is odd")
...>       :odd
...>   end
```

Isso ajuda a lidar com erros provendo padrões parecido com o case. O valor passado para o else é o primeiro que não foi correspondido com o padrão em uma expressão.

# Sigils

Elixir fornece uma sintaxe alternativa para representar e trabalhar com literais. Um sigil (símbolo especial) vai começar com um til ~ seguido por um caractere. O núcleo do Elixir fornece-nos alguns sigils, no entanto, é possível criar o nosso próprio quando precisamos estender a linguagem.

Uma lista de sigils disponíveis incluem:

- ~C Gera uma lista de caracteres sem escape ou interpolação
- ~c Gera uma lista de caracteres com escape e interpolação
- ~R Gera uma expressão regular sem escape ou interpolação
- ~r Gera uma expressão regular com escape e interpolação
- ~S Gera strings sem escape ou interpolação
- ~s Gera string com escape e interpolação
- ~W Gera uma lista sem escape ou interpolação
- ~w Gera uma lista com escape e interpolação
- ~N Gera uma NaiveDateTime struct

Uma lista de delimitadores inclui:

- <...> Um par de brackets
- {...} Um par de chaves
- [...] Um par de colchetes
- (...) Um par de parênteses
- |...| Um par de pipes
- /.../ Um par de barras
- "..." Um par de aspas duplas
- '...' Um par de aspas simples

## Lista de Caracteres

O ~c e ~C sigils geram listas de caracteres respectivamente. Por exemplo:

```elixir
iex> ~c/2 + 7 = #{2 + 7}/
'2 + 7 = 9'

iex> ~C/2 + 7 = #{2 + 7}/
'2 + 7 = \#{2 + 7}'
```

Podemos ver em letra minúscula ~c interpolando o cálculo, enquanto um sigil de letra maiúscula ~C não. Veremos que esta sequência maiúscula / minúscula é um tema comum em toda a construção de sigils.


## Sigils para Strings

O ~s e ~S sigils são usados para gerar dados de String. Por exemplo:

```elixir
iex> ~s/the cat in the hat on the mat/
"the cat in the hat on the mat"

iex> ~S/the cat in the hat on the mat/
"the cat in the hat on the mat"
```

Mas qual é a diferença? A diferença é semelhante ao sigil da lista de palavras em que estamos procurando. A resposta é interpolação e o uso de sequências de escape. Se pegarmos outro exemplo:

```elixir
iex> ~s/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir school"

iex> ~S/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir \#{String.downcase \"SCHOOL\"}"
```

## Lista de Palavras

A lista de palavras do tipo sigil pode ser muito útil. Pode lhe economizar tempo, digitação e possivelmente, reduzir a complexidade dentro da base de código. Veja este exemplo simples:

```elixir
iex> ~w/i love elixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love elixir school/
["i", "love", "elixir", "school"]
```

Podemos ver que o que é digitado entre os delimitadores é separado por espaços em branco em uma lista. No entanto, não existe qualquer diferença entre estes dois exemplos. Novamente, a diferença vem com as seguintes sequências de interpolação e escape. Veja o seguinte exemplo:

```elixir
iex> ~w/i love #{'e'}lixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love #{'e'}lixir school/
["i", "love", "\#{'e'}lixir", "school"]
```

## Mais sobre módulos (PRECISA?)

Os módulos permitem a organização de funções em um namespace. Além de agrupar funções, eles permitem definir funções nomeadas e privadas que cobrimos na lição sobre funções.

Vejamos um exemplo básico:

```elixir
iex> defmodule Example do
...>  def greeting(name) do
...>     "Hello #{name}."
...>   end
...> end

iex> Example.greeting "Sean"
"Hello Sean."
```

É possível aninhar módulos em Elixir, permitindo-lhe promover um namespace para a sua funcionalidade:

```elixir
iex> defmodule Example.Greetings do
...>   def morning(name) do
...>     "Good morning #{name}."
...>   end

...>   def evening(name) do
...>     "Good night #{name}."
...>   end
...> end


iex> Example.Greetings.morning "Sean"
"Good morning Sean."
```

## Atributos de Módulo (PRECISA?)

Atributos de módulo são mais comumente usados como constantes no Elixir. Vamos dar uma olhada em um exemplo simples:

```elixir
iex> defmodule Example do
...>   @greeting "Hello"

...>   def greeting(name) do
...>     ~s(#{@greeting} #{name}.)
...>   end
...> end
```

É importante notar que existem atributos reservados no Elixir. Os três mais comuns são:

- moduledoc — Documenta o módulo atual.
- doc — Documentação para funções e macros.
- behaviour — Usa um OTP ou comportamento definido.


# Compreensões

Em alguns casos comprehensions podem ser usadas para produzir código mais conciso para fazer iterações com Enum e Stream. Vamos começar olhando para uma comprehension simples e então observar suas várias partes:

```elixir
iex> list = [1, 2, 3, 4, 5]
iex> for x <- list, do: x*x
[1, 4, 9, 16, 25]
```

A primeira coisa que observamos é o uso de for e um generator (gerador). O que é um generator? Generators são as expressões x <- [1, 2, 3, 4] encontradas em comprehensions. Eles são responsáveis por gerar o próximo valor.

Para nossa sorte, comprehensions não são limitadas a listas; na verdade elas funcionam com qualquer enumerable:

```elixir
# Keyword Lists
iex> for {_key, val} <- [one: 1, two: 2, three: 3], do: val
[1, 2, 3]

# Maps
iex> for {k, v} <- %{"a" => "A", "b" => "B"}, do: {k, v}
[{"a", "A"}, {"b", "B"}]

# Binaries
iex> for <<c <- "hello">>, do: <<c>>
["h", "e", "l", "l", "o"]
```

Como muitas outras coisas em Elixir, generators se apoiam no pattern matching para comparar a entrada definida na variável à esquerda. Caso um match não seja encontrado, o valor é ignorado.

```elixir
iex> for {:ok, val} <- [ok: "Hello", error: "Unknown", ok: "World"], do: val
["Hello", "World"]
```

É possível utilizar múltiplos generators, bem como loops aninhados:

```elixir
iex> list = [1, 2, 3, 4]
iex> for n <- list, times <- 1..n do
...>  String.duplicate("*", times)
...> end
["*", "*", "**", "*", "**", "***", "*", "**", "***", "****"]
```

Para ilustrar melhor cada iteração do loop, vamos usar IO.puts para mostrar os dois valores gerados:

```elixir
iex> for n <- list, times <- 1..n, do: IO.puts "#{n} - #{times}"
1 - 1
2 - 1
2 - 2
3 - 1
3 - 2
3 - 3
4 - 1
4 - 2
4 - 3
4 - 4
```

Comprehensions são syntactic sugar e devem ser utilizadas apenas quando for apropriado.

## Filtros

Você pode pensar em filtros como um tipo de guard para comprehensions. Quando um valor filtrado retorna false ou nil ele é excluído da lista final. Vamos iterar por um intervalo e olhar apenas os números pares. Nós vamos usar a função is_even/1 do módulo Integer para checar se um valor é par ou não.

```elixir
iex> import Integer
iex> for x <- 1..10, is_even(x), do: x
[2, 4, 6, 8, 10]
```

Assim como os generators, nós podemos usar múltiplos filtros. Vamos expandir nosso intervalo e então filtrar apenas para valores que sejam pares e também divisíveis por 3.

```elixir
iex> import Integer
iex> for x <- 1..100,
...>  is_even(x),
...>  rem(x, 3) == 0, do: x
[6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96]
```

## Usando :Into

E se nós quisermos produzir algo que não seja uma lista? Passando a opção :into nós podemos fazer exatamente isso! Como uma regra geral, :into aceita qualquer estrutura que implemente o protocolo Collectable.

Usando :into, vamos criar um mapa de uma lista de palavras-chave.

```elixir
iex> for {k, v} <- [one: 1, two: 2, three: 3], into: %{}, do: {k, v}
%{one: 1, three: 3, two: 2}
```

Como bitstrings implementam collectables nós podemos usar comprehensions e :into para criar strings:

```elixir
iex> for c <- [72, 101, 108, 108, 111], into: "", do: <<c>>
"Hello"
```

## Exercício

## Links

Se você quiser saber mais, recomendamos abaixo alguns links que podem ser úteis:
- [Elixir School](https://elixirschool.com/pt) - Site que contém várias "lições" em português.
- Livros
- Vídeos (eu e ElixirLab)
- Cursos (Groxio, ElxPro, Rafa Camarda)
- Comunidade Telegram
