# Learn4Elixir - Capítulo 3

## Estruturas de Controle

Neste capitulo iremos nos aprofundar em Estruturas de Controle.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter3.livemd)

## If e Unless

If e Unless são estruturas de controle que você pode usar no Livebook, uma ferramenta interativa e documentação para a linguagem de programação Elixir. Eles funcionam de maneira semelhante ao condicional if e unless em outras linguagens de programação. Aqui está como você pode usá-los:

## If

A estrutura if é usada para executar um bloco de código se uma condição for avaliada como verdadeira (true). Se a condição for avaliada como falsa (false), o bloco de código não será executado.

```
if condition do
  # Código a ser executado se a condição for verdadeira
end
```

Exemplo:

```elixir
age = 25

if age >= 18 do
  IO.puts("Você é maior de idade.")
end
```

## Unless

A estrutura unless é o oposto do if. Ela é usada para executar um bloco de código se a condição for avaliada como falsa (false). Se a condição for avaliada como verdadeira (true), o bloco de código não será executado.

```
unless condition do
  # Código a ser executado se a condição for falsa
end
```

Exemplo:

```elixir
raining = true

unless raining do
  IO.puts("Não está chovendo.")
end
```

Você também pode usar else com if e unless para executar um bloco de código alternativo quando a condição não for atendida.

```
if condition do
  # Código a ser executado se a condição for verdadeira
else
  # Código a ser executado se a condição for falsa
end
```

Exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
temperature = 28
if temperature > 30 do
  IO.puts("Está quente lá fora.")
else
  IO.puts("Não está tão quente lá fora.")
end
```

A mesma lógica se aplica ao unless com else.

## Cond

No Livebook, você pode usar a macro cond para criar uma estrutura de controle condicional que permite avaliar múltiplas condições e executar código com base na primeira condição verdadeira encontrada. A sintaxe básica do cond é a seguinte:

```
cond do
  condition1 ->
    # Código a ser executado se condition1 for verdadeira

  condition2 ->
    # Código a ser executado se condition2 for verdadeira

  condition3 ->
    # Código a ser executado se condition3 for verdadeira

  true ->
    # Código a ser executado se nenhuma das condições anteriores for verdadeira
end
```

Aqui estão alguns pontos-chave a serem observados sobre o cond no Livebook:

O cond avaliará as condições na ordem em que são declaradas e executará o código associado à primeira condição verdadeira encontrada. Se nenhuma das condições for verdadeira, o bloco de código associado a true será executado, se presente.

As condições são seguidas por uma seta (->) e, em seguida, o código a ser executado se a condição for verdadeira.

A última cláusula com true é opcional, mas é uma boa prática incluí-la para tratar casos em que nenhuma das condições anteriores é verdadeira.

Aqui está um exemplo de uso do cond no Livebook:

<!-- livebook:{"force_markdown":true} -->

```elixir
x = 5

cond do
  x == 0 ->
    IO.puts("x é igual a 0")

  x > 0 ->
    IO.puts("x é maior que 0")

  x < 0 ->
    IO.puts("x é menor que 0")

  true ->
    IO.puts("Nenhuma das condições anteriores foi atendida")
end
```

Neste exemplo, o código verificará a condição x == 0 primeiro, que não é verdadeira, e, em seguida, verificará x > 0, que é verdadeira, portanto, imprimirá "x é maior que 0". Como a última cláusula com true está presente, ela não será executada neste caso.

## Sigils

Elixir fornece uma sintaxe alternativa para representar e trabalhar com literais. Um sigil (símbolo especial) vai começar com um til ~ seguido por um caractere. O núcleo do Elixir fornece-nos alguns sigils, no entanto, é possível criar o nosso próprio quando precisamos estender a linguagem.

Uma lista de sigils disponíveis incluem:

* ~C Gera uma lista de caracteres sem escape ou interpolação
* ~c Gera uma lista de caracteres com escape e interpolação
* ~R Gera uma expressão regular sem escape ou interpolação
* ~r Gera uma expressão regular com escape e interpolação
* ~S Gera strings sem escape ou interpolação
* ~s Gera string com escape e interpolação
* ~W Gera uma lista sem escape ou interpolação
* ~w Gera uma lista com escape e interpolação
* ~N Gera uma NaiveDateTime struct

Uma lista de delimitadores inclui:

* <...> Um par de brackets
* {...} Um par de chaves
* [...] Um par de colchetes
* (...) Um par de parênteses
* |...| Um par de pipes
* /.../ Um par de barras
* "..." Um par de aspas duplas
* '...' Um par de aspas simples

Aqui estão alguns exemplos de como usar sigils no Livebook:

## Sigil de String (~s)

Você pode usar o sigil ~s para criar strings. O texto deve ser colocado entre colchetes {}. Por exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
minha_string = ~s{Isso é uma string criada com sigil}
IO.puts(minha_string)
```

Isso imprimirá "Isso é uma string criada com sigil" na saída.

### Sigil de Regex (~r)

O sigil ~r permite criar expressões regulares. Você pode delimitar a expressão regular com barras /. Por exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
regex = ~r/\\d+/  # Esta expressão regular corresponde a um ou mais dígitos.
texto = "123 ABC"
resultado = Regex.scan(regex, texto)
IO.inspect(resultado)
```

Isso irá corresponder e retornar uma lista com o número "123" da string "123 ABC".

## Sigil de Caracter (~c)

O sigil ~c permite criar caracteres. Você pode especificar um único caractere entre aspas simples '. Por exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
meu_char = ~c'A'
IO.puts(meu_char)
```

Isso imprimirá "A" na saída.

Sigil de Listas (~w):

O sigil ~w permite criar listas de palavras (atomos). Você pode delimitar as palavras com espaços. Por exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
lista_palavras = ~w(apple banana cherry)
IO.inspect(lista_palavras)
```

Isso criará uma lista de átomos com os valores [ :apple, :banana, :cherry ].

## Compreensões

No Livebook, você pode usar compreensões para criar listas ou outras estruturas de dados de maneira concisa e expressiva. Compreensões são uma característica poderosa em Elixir e podem ajudar a simplificar a criação e transformação de coleções de dados. Aqui estão algumas formas de usar compreensões no Livebook:

Compreensões de Lista:

Você pode criar listas usando compreensões de lista. A estrutura básica de uma compreensão de lista é a seguinte:

```
for pattern <- enumerable, filter, do: expression
```

* pattern é uma variável que representa cada elemento da coleção enumerable.
* enumerable é uma coleção de dados, como uma lista, um mapa ou um conjunto.
* filter (opcional) é uma condição que filtra os elementos da coleção.
* expression é o valor que será incluído na lista resultante.

Exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
lista = [1, 2, 3, 4, 5]
quadrados = for x <- lista, do: x * x
quadrados
```

## Compreensões de Mapa

Você também pode usar compreensões para criar mapas. A estrutura básica de uma compreensão de mapa é semelhante à compreensão de lista:

<!-- livebook:{"force_markdown":true} -->

```elixir
for {key, value} <- enumerable, filter, do: {key, expression}
```

Exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
mapa = %{"a" => 1, "b" => 2, "c" => 3}
triplica_valores = for {chave, valor} <- mapa, do: {chave, valor * 3}
triplica_valores
```

## Compreensões Aninhadas

Você pode aninhar compreensões dentro de outras compreensões para trabalhar com coleções mais complexas. Por exemplo, você pode criar uma lista de listas usando uma compreensão aninhada.

Exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
elementos_pares = for linha <- matriz, valor <- linha, rem(valor, 2) == 0, do: valor
elementos_pares
```

## Guard Clauses

Você pode usar guard clauses nas compreensões para aplicar condições adicionais aos elementos.

Exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
lista = [1, 2, 3, 4, 5, 6]
pares_maiores_que_tres = for x <- lista, rem(x, 2) == 0, x > 3, do: x
pares_maiores_que_tres
```

## Filtros

No Livebook, você pode usar filtros para selecionar e exibir apenas as saídas ou resultados específicos de uma célula. Isso pode ser útil quando você deseja reduzir o ruído em seu notebook ou concentrar-se apenas em resultados relevantes. Os filtros são uma maneira conveniente de organizar e visualizar as saídas de suas células.

Aqui está como usar filtros no Livebook:

## Adicione um Filtro em uma Célula

Você pode adicionar um filtro a uma célula especificando o filtro desejado usando a função put_result/2. O primeiro argumento da função é o nome do filtro, e o segundo argumento é o resultado que você deseja associar a esse filtro. O resultado pode ser qualquer valor, como uma string, número ou lista.

<!-- livebook:{"force_markdown":true} -->

```elixir
IO.puts("Isso será exibido sem filtro")
put_result(:filtro_personalizado, "Isso será exibido com um filtro")
```

## Defina Filtros em Outras Células

Depois de adicionar um filtro a uma célula, você pode definir esse filtro em células subsequentes usando a função set_filter/1. O argumento da função é o nome do filtro que você deseja aplicar.

<!-- livebook:{"force_markdown":true} -->

```elixir
set_filter(:filtro_personalizado)
```

Agora, todas as saídas de células subsequentes serão filtradas de acordo com o filtro :filtro_personalizado. Isso significa que apenas as saídas associadas a esse filtro serão exibidas.

### Remova ou Limpe um Filtro

Para remover um filtro, você pode usar a função clear_filter/1 com o nome do filtro que deseja remover.

<!-- livebook:{"force_markdown":true} -->

```elixir
clear_filter(:filtro_personalizado)
```

Isso fará com que as saídas voltem a ser exibidas sem filtro.

## Filtros Padrão

O Livebook também oferece alguns filtros padrão que você pode usar para controlar as saídas. Alguns exemplos incluem :error, :stderr, :stdout, que podem ser úteis para capturar mensagens de erro ou saída padrão.

Aqui está um exemplo completo de como usar filtros no Livebook:

<!-- livebook:{"force_markdown":true} -->

```elixir
# Célula 1: Definindo um filtro personalizado
IO.puts("Isso será exibido sem filtro")
put_result(:filtro_personalizado, "Isso será exibido com um filtro")

# Célula 2: Aplicando o filtro personalizado
set_filter(:filtro_personalizado)

# Célula 3: Exibindo uma saída filtrada
IO.puts("Esta saída está filtrada pelo filtro_personalizado")

# Célula 4: Removendo o filtro personalizado
clear_filter(:filtro_personalizado)

# Célula 5: Exibindo saída sem filtro novamente
IO.puts("Esta saída não está filtrada
```

## Usando :Into

Em uma célula do Livebook, você pode usar a função into/2 para criar uma associação a uma variável que receberá o resultado da expressão na célula. Isso é útil quando você deseja armazenar o resultado de uma computação em uma variável para uso posterior ou para exibir o valor em uma célula subsequente. A sintaxe básica do into/2 é a seguinte:

<!-- livebook:{"force_markdown":true} -->

```elixir
resultado = expressao |> into(variavel)
```

Onde:

* resultado é a variável que armazenará o resultado da expressão.
* expressao é a expressão cujo resultado você deseja armazenar.
* variavel é a variável na qual você deseja armazenar o resultado.

Aqui está um exemplo de uso do into/2 no Livebook:

<!-- livebook:{"force_markdown":true} -->

```elixir
# Suponha que você queira calcular a soma de dois números.
a = 5
b = 7

# Use o into/2 para armazenar o resultado em uma variável chamada "soma".
soma = a + b |> into(soma)

# Agora, a variável "soma" contém o resultado.
soma
```

Neste exemplo, a variável soma armazenará o resultado da soma de a e b. Quando você executar a célula, o valor da variável soma será calculado e exibido na célula subsequente.

## Exercício

### Exercício 1

Você é um desenvolvedor Elixir que trabalha para uma empresa de jogos chamada "ElixGames". A empresa está criando um jogo de aventura em que os jogadores exploram um mundo mágico cheio de criaturas misteriosas. Como parte do jogo, você precisa implementar uma função que determina o resultado de um encontro aleatório com uma criatura.

Aqui estão as regras para determinar o resultado do encontro:

* Se o jogador estiver em um "Bosque Encantado", ele tem 90% de chance de encontrar uma criatura amigável e 10% de chance de encontrar uma criatura hostil.
* Se o jogador estiver em uma "Caverna Escura", ele tem 60% de chance de encontrar uma criatura amigável e 40% de chance de encontrar uma criatura hostil.
* Se o jogador estiver em uma "Torre Misteriosa", ele tem 30% de chance de encontrar uma criatura amigável e 70% de chance de encontrar uma criatura hostil.

Sua tarefa é implementar um módulo em Elixir chamado `ElixGames.Encontro` que forneça a função `determina_encontro/2`, que aceita o local onde o jogador está e um número aleatório entre 1 e 100 (representando a probabilidade) como argumentos e retorna o resultado do encontro com a criatura com base nas regras acima.

Para completar esta tarefa, você precisará usar estruturas condicionais, como `if`, `unless` e `cond`, para aplicar as regras corretamente e determinar se o jogador encontrará uma criatura amigável ou hostil com base no local e na probabilidade gerada aleatoriamente. Certifique-se de que a API (o nome do módulo, da função e suas assinaturas) seja respeitada, conforme especificado pela empresa "ElixGames".

```elixir
defmodule ElixGames.Encontro do
  def determina_encontro(localizacao, probabilidade) do
    # Implemente a lógica de determinação do resultado do encontro aqui
  end
end
```

```elixir

```

### Exercício 2

Você recebeu uma lista de informações de clientes em formato de string, mas elas estão desorganizadas e precisam ser formatadas corretamente. Cada informação de cliente é separada por um ponto e vírgula (;) e contém os seguintes campos:

1. Nome do cliente (entre aspas duplas).
2. Idade do cliente (um número).
3. Endereço de e-mail do cliente.
4. Número de telefone do cliente.

A seguir está um exemplo de como as informações dos clientes estão atualmente:

<!-- livebook:{"force_markdown":true} -->

```elixir
"Fulano Tal",30,fulano@email.com,+5511995236587;"Ciclano Outro",25,ciclano@email.com,5545996578452
```

> Dê uma olhada como **sigils** funcionam. Principalmente `~s` e `~r`, leia também sobre **expressões regulares**.

**Tarefas:**

<!-- livebook:{"break_markdown":true} -->

1. Crie uma função chamada `parsear_clientes/1` que receba a string de informações de clientes e a divida em uma lista de informações de clientes formatadas. Use o sigil `~s` para fazer isso.

```elixir
def parsear_clientes(informacao) do
  # A fazer
end
```

```elixir

```

1. Crie outra função chamada `extrair_nomes/1` que receba a lista de informações de clientes e retorne uma lista com os nomes dos clientes.

```elixir
def extrair_nomes(clientes) do
  # A fazer
end
```

```elixir
# Caso a entrada fosse o exemplo na descrição deve imprimir ["Fulano Tal", "Ciclano Outro"]
```

1. Crie uma terceira função chamada `filtrar_clientes_por_idade/2` que receba a lista de informações de clientes e uma idade mínima e retorne uma lista com as informações dos clientes que têm pelo menos a idade especificada.

```elixir
def filtrar_clientes_por_idade(clientes, idade_minima) do
  # A fazer
end
```

```elixir
# Deveria imprimir [["Fulano Tal", 30, "fulano@email.com", "+5511995236587"]]
```

### Exercicio 3

Você está trabalhando em uma empresa de e-commerce que vende produtos para pets. Você recebeu a tarefa de implementar uma função que calcula o valor total de uma compra, aplicando possíveis descontos de acordo com as regras de negócio. As regras são as seguintes:

* Se a compra for acima de R$ 200,00, o cliente ganha 10% de desconto.
* Se a compra for acima de R$ 500,00, o cliente ganha 15% de desconto.
* Se a compra for acima de R$ 1000,00, o cliente ganha 20% de desconto.
* Se o cliente for um membro do clube de fidelidade, ele ganha mais 5% de desconto em qualquer compra.
* Se o cliente usar o cupom "UBL10", ele ganha mais 10% de desconto em qualquer compra.

Você deve implementar uma função chamada `calcula_total` que recebe uma lista de produtos e um mapa com as informações do cliente (se ele é membro do clube, se ele usou o cupom, etc) e retorna o valor total da compra com os descontos aplicados. Você pode usar funções de alta ordem para criar funções auxiliares que representam as regras de desconto e aplicá-las na lista de produtos. Cada produto é representado por um mapa com os campos `:nome`, `:preco` e `:quantidade`. Por exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
produtos = [
  %{nome: "Ração para gatos", preco: 50.00, quantidade: 2},
  %{nome: "Brinquedo para cachorro", preco: 30.00, quantidade: 1},
  %{nome: "Aquário", preco: 200.00, quantidade: 1}
]

cliente = %{
  membro_clube: true,
  cupom: "UBL10"
}

calcula_total(produtos, cliente) # deve retornar 243.00
```

```elixir
defmodule Ecommerce do
  # A fazer
end
```

```elixir

```
