## Estruturas de controle 

### If e Unless
Existem chances de que você já tenha encontrado if/2 antes, e caso você tenha utilizado Ruby você é familiarizado com unless/2. Em Elixir eles trabalham praticamente da mesma forma porém são definidos como macros, não construtores da linguagem; Você pode encontrar a implementação deles em Kernel module.

Pode-se notar que em Elixir, os únicos valores falsos são nil e o booleano false.

```elixir
iex> if String.valid?("Hello") do
...>  "Valid string!"
...> else
...>   "Invalid string."
...> end
"Valid string!"

iex> if "a string value" do
...>   "Truthy"
...> end
"Truthy"
```

Usar unless/2 é bem parecido com o uso do if/2 porém trabalhando de forma negativa:

```elixir
iex> unless is_integer("hello") do
...>   "Not an Int"
...> end
"Not an Int"
```
### Case
Caso seja necessário combinar múltiplos padrões nós poderemos utilizar case/2:

```elixir
iex> case {:ok, "Hello World"} do
...>  {:ok, result} -> result
...>  {:error} -> "Uh oh!"
...>  _ -> "Catch all"
...> end
"Hello World"
```

A variável _ é uma importante inclusão na declaração do case/2. Sem isso a falha em procura de combinação iria causar um erro:

```elixir
iex> case :even do
...>   :odd -> "Odd"
...> end
** (CaseClauseError) no case clause matching: :even

iex> case :even do
...>  :odd -> "Odd"
...>  _ -> "Not Odd"
...> end
"Not Odd"
```

Considere _ como o else que irá igualar com “todo o resto”. Já que case/2 depende de combinação de padrões, todas as mesmas regras e restrições são aplicadas. Se você pretende procurar padrões em variáveis que já existem, você irá precisar utilizar o operador pin ^/1:

```elixir
iex> pie = 3.14
3.14
...> case "cherry pie" do
...>  ^pie -> "Not so tasty"
...>   pie -> "I bet #{pie} is tasty"
...> end
"I bet cherry pie is tasty"
```

Outra característica interessante do case/2 é o seu suporte para cláusulas de guarda:

Este exemplo vem diretamente do Guia Introdutório oficial do Elixir.

```elixir
iex> case {1, 2, 3} do
...>  {1, x, 3} when x > 0 ->
...>     "Will match"
...>   _ ->
...>     "Won't match"
...> end
"Will match"
```

Verifique a documentação oficial sobre Expressões permitidas em cláusulas guard.

### Cond
Quando necessitamos associar condições, e não valores, nós podemos recorrer ao cond/1; Isso é semelhante ao else if ou elsif de outras linguagens:

Este exemplo vem diretamente do Guia Introdutório oficial do Elixir.

```elixir
iex> cond do
...>   2 + 2 == 5 ->
...>     "This will not be true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   1 + 1 == 2 ->
...>     "But this will"
...> end
"But this will"
```
Como case/2, cond/1 irá gerar um erro caso não seja achado associação. Para lidar com isso, nós podemos definir a condição para true:

```elixir
iex> cond do
...>   7 + 1 == 0 -> "Incorrect"
...>   true -> "Catch all"
...> end
"Catch all"
```
### With
A forma especial with/1 é útil quando tentamos usar case/2 de maneira aninhada ou em situações que não é possível encadear funções. A expressão with/1 é composta de palavras-chaves, generators e finalmente uma expressão.

Iremos discutir generators na lição sobre list comprehensions para comparar o lado direito do operador <- com o lado esquerdo.

Vamos começar com um exemplo simples de with/1 e então vamos olhar em algo mais:

```elixir
iex> user = %{first: "Sean", last: "Callan"}
...> %{first: "Sean", last: "Callan"}
...> with {:ok, first} <- Map.fetch(user, :first),
...>      {:ok, last} <- Map.fetch(user, :last),
...>      do: last <> ", " <> first
"Callan, Sean"
```

Quando uma expressão falha em achar um padrão, o valor da expressão que falhou será retornado:

```elixir
iex> user = %{first: "doomspork"}
...> %{first: "doomspork"}
...> with {:ok, first} <- Map.fetch(user, :first),
 ...>     {:ok, last} <- Map.fetch(user, :last),
 ...>     do: last <> ", " <> first
:error
```

Agora vamos olhar um exemplo maior sem with/1 e então ver como nós podemos refatorar:

```elixir
iex> case Repo.insert(changeset) do
...>   {:ok, user} ->
...>     case Guardian.encode_and_sign(user, :token, claims) do
...>       {:ok, token, full_claims} ->
...>         important_stuff(token, full_claims)

...>       error ->
...>         error
...>     end

...>   error ->
...>     error
...> end
```

Quando utilizamos with/1 acabamos com um código que é facilmente entendido e possui menos linhas:

```elixir
iex> with {:ok, user} <- Repo.insert(changeset),
...>      {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
...>   important_stuff(token, full_claims)
...> end
```

A partir do Elixir 1.3, with/1 suporta else:

```elixir
iex> import Integer

...> m = %{a: 1, c: 3}

...> a =
...>   with {:ok, number} <- Map.fetch(m, :a),
...>     true <- is_even(number) do
...>       IO.puts "#{number} divided by 2 is #{div(number, 2)}"
...>       :even
...>   else
...>     :error ->
...>       IO.puts("We don't have this item in map")
...>       :error

...>     _ ->
...>       IO.puts("It is odd")
...>       :odd
...>   end
```

Isso ajuda a lidar com erros provendo padrões parecido com o case. O valor passado para o else é o primeiro que não foi correspondido com o padrão em uma expressão.

## Sigils

Elixir fornece uma sintaxe alternativa para representar e trabalhar com literais. Um sigil (símbolo especial) vai começar com um til ~ seguido por um caractere. O núcleo do Elixir fornece-nos alguns sigils, no entanto, é possível criar o nosso próprio quando precisamos estender a linguagem.

Uma lista de sigils disponíveis incluem:

- ~C Gera uma lista de caracteres sem escape ou interpolação
- ~c Gera uma lista de caracteres com escape e interpolação
- ~R Gera uma expressão regular sem escape ou interpolação
- ~r Gera uma expressão regular com escape e interpolação
- ~S Gera strings sem escape ou interpolação
- ~s Gera string com escape e interpolação
- ~W Gera uma lista sem escape ou interpolação
- ~w Gera uma lista com escape e interpolação
- ~N Gera uma NaiveDateTime struct

Uma lista de delimitadores inclui:

- <...> Um par de brackets
- {...} Um par de chaves
- [...] Um par de colchetes
- (...) Um par de parênteses
- |...| Um par de pipes
- /.../ Um par de barras
- "..." Um par de aspas duplas
- '...' Um par de aspas simples

### Lista de Caracteres

O ~c e ~C sigils geram listas de caracteres respectivamente. Por exemplo:

```elixir
iex> ~c/2 + 7 = #{2 + 7}/
'2 + 7 = 9'

iex> ~C/2 + 7 = #{2 + 7}/
'2 + 7 = \#{2 + 7}'
```

Podemos ver em letra minúscula ~c interpolando o cálculo, enquanto um sigil de letra maiúscula ~C não. Veremos que esta sequência maiúscula / minúscula é um tema comum em toda a construção de sigils.

### Expressões Regulares

O ~r e ~R sigils são usados para representar Expressões Regulares. Nós criamos ambos dentro de funções Regex. Por exemplo:

```elixir
iex> re = ~r/elixir/
~r/elixir/

iex> "Elixir" =~ re
false

iex> "elixir" =~ re
true
```

Podemos ver que no primeiro teste de igualdade, Elixir não coincide com a expressão regular. Isso acontece porque ele está utilizando letra maiúscula. Pelo fato de Elixir suportar expressões regulares compatíveis com Perl (PCRE), podemos acrescentar i ao final do nosso sigil para ligar maiúsculas e minúsculas.

```elixir
iex> re = ~r/elixir/i
~r/elixir/i

iex> "Elixir" =~ re
true

iex> "elixir" =~ re
true
```

Além disso, Elixir fornece a API Regex, que é construída em cima da biblioteca de expressão regular do Erlang. Vamos implementar Regex.split/2 usando um sigil regex.

```elixir
iex> string = "100_000_000"
"100_000_000"

iex> Regex.split(~r/_/, string)
["100", "000", "000"]
```

Como podemos ver, a string "100_000_000" é dividida nas barras sublinhadas graças ao nosso ~r/_/ sigil. A função Regex.split retorna uma lista.

### String
O ~s e ~S sigils são usados para gerar dados de String. Por exemplo:

```elixir
iex> ~s/the cat in the hat on the mat/
"the cat in the hat on the mat"

iex> ~S/the cat in the hat on the mat/
"the cat in the hat on the mat"
```

Mas qual é a diferença? A diferença é semelhante ao sigil da lista de palavras em que estamos procurando. A resposta é interpolação e o uso de sequências de escape. Se pegarmos outro exemplo:

```elixir
iex> ~s/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir school"

iex> ~S/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir \#{String.downcase \"SCHOOL\"}"
```

### Lista de Palavras

A lista de palavras do tipo sigil pode ser muito útil. Pode lhe economizar tempo, digitação e possivelmente, reduzir a complexidade dentro da base de código. Veja este exemplo simples:

```elixir
iex> ~w/i love elixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love elixir school/
["i", "love", "elixir", "school"]
```

Podemos ver que o que é digitado entre os delimitadores é separado por espaços em branco em uma lista. No entanto, não existe qualquer diferença entre estes dois exemplos. Novamente, a diferença vem com as seguintes sequências de interpolação e escape. Veja o seguinte exemplo:

```elixir
iex> ~w/i love #{'e'}lixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love #{'e'}lixir school/
["i", "love", "\#{'e'}lixir", "school"]
```

### NaiveDateTime

Uma NaiveDateTime pode ser bem útil para criar rapidamente uma struct que representa um DateTime sem um timezone.

Geralmente, nós devemos evitar criar uma NaiveDateTime struct diretamente. No entanto, é muito útil para pattern matching. Por exemplo:

```elixir
iex> NaiveDateTime.from_iso8601("2015-01-23 23:50:07") == {:ok, ~N[2015-01-23 23:50:07]}
```
### Criando Sigils

Um dos objetivos do Elixir é ser uma linguagem de programação extensível. Não é surpresa então que você possa facilmente criar o seu próprio sigil customizado. Neste exemplo, vamos criar um sigil para converter uma cadeia para letras maiúsculas. Como já existe uma função para isso no núcleo do Elixir (String.upcase/1), vamos embrulhar o nosso sigil em torno desta função.

```elixir
iex> defmodule MySigils do
...>  def sigil_u(string, []), do: String.upcase(string)
...> end

iex> import MySigils
nil

iex> ~u/elixir school/
ELIXIR SCHOOL
```

Primeiro definimos um módulo chamado MySigils e dentro deste módulo, criamos uma função chamada sigil_u. Como não existe nenhum sigil ~u no espaço de sigil existente, vamos usá-lo. O _u indica que desejamos usar u como caractere depois do til. A definição da função deve receber dois argumentos, uma entrada e uma lista.

## Mais sobre módulos 

  - Structs
  - Atributos de módulo
  - Composição (alias, use, import, require)

https://elixirschool.com/pt/lessons/basics/modules

## Compreensões

https://elixirschool.com/pt/lessons/basics/comprehensions
